<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Nebula: Util::HashTable&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; Class Template Reference</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Nebula
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_util_1_1_hash_table.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_util_1_1_hash_table-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Util::HashTable&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="hashtable_8h_source.html">hashtable.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class KEYTYPE, class VALUETYPE, int TABLE_SIZE = 128, int STACK_SIZE = 1&gt;<br />
class Util::HashTable&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;</h3>

<p>Organizes key/value pairs by a hash code. </p>
<p>Looks very similar to a <a class="el" href="class_util_1_1_dictionary.html" title="A collection of key/value pairs with quick value retrieval by key at roughly O(log n).">Dictionary</a>, but may provide better search times (up to O(1)) by computing a (ideally unique) hash code on the key and using that as an index into an array. The flipside is that the key class must provide a hash code and the memory footprint may be larger then <a class="el" href="class_util_1_1_dictionary.html" title="A collection of key/value pairs with quick value retrieval by key at roughly O(log n).">Dictionary</a>.</p>
<p>The default capacity is 128. Matching the capacity against the number of expected elements in the hash table is one key to get optimal insertion and search times, the other is to provide a good (and fast) hash code computation which produces as few collissions as possible for the key type.</p>
<p>The key class must implement the following method in order to work with the <a class="el" href="class_util_1_1_hash_table.html" title="Organizes key/value pairs by a hash code.">HashTable</a>: <br  />
 uint32_t HashCode() const;</p>
<p>The <a class="el" href="class_util_1_1_string.html" title="Nebula&#39;s universal string class.">Util::String</a> class implements this method as an example. Internally the hash table is implemented as a fixed array of sorted arrays. The fixed array is indexed by the hash code of the key, the sorted arrays contain all values with identical keys.</p>
<dl class="section copyright"><dt>Copyright</dt><dd>(C) 2006 Radon Labs GmbH (C) 2013-2020 Individual contributors, see AUTHORS file </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table_1_1_iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6168ec5e95041586c9f69037e90591cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a6168ec5e95041586c9f69037e90591cb">HashTable</a> ()</td></tr>
<tr class="memdesc:a6168ec5e95041586c9f69037e90591cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="class_util_1_1_hash_table.html#a6168ec5e95041586c9f69037e90591cb">More...</a><br /></td></tr>
<tr class="separator:a6168ec5e95041586c9f69037e90591cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b47f9feddc4608cdd32c47ed96d770c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a7b47f9feddc4608cdd32c47ed96d770c">HashTable</a> (const <a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7b47f9feddc4608cdd32c47ed96d770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="class_util_1_1_hash_table.html#a7b47f9feddc4608cdd32c47ed96d770c">More...</a><br /></td></tr>
<tr class="separator:a7b47f9feddc4608cdd32c47ed96d770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2338141dd260d398b004f7fe53e886b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a2338141dd260d398b004f7fe53e886b6">HashTable</a> (<a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a2338141dd260d398b004f7fe53e886b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="class_util_1_1_hash_table.html#a2338141dd260d398b004f7fe53e886b6">More...</a><br /></td></tr>
<tr class="separator:a2338141dd260d398b004f7fe53e886b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4926e7a91bb4d52ae823ef961cda86d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a4926e7a91bb4d52ae823ef961cda86d6">operator=</a> (const <a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4926e7a91bb4d52ae823ef961cda86d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator  <a href="class_util_1_1_hash_table.html#a4926e7a91bb4d52ae823ef961cda86d6">More...</a><br /></td></tr>
<tr class="separator:a4926e7a91bb4d52ae823ef961cda86d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ccee59b4b2af252f5b8b6351ccdfb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#af0ccee59b4b2af252f5b8b6351ccdfb2">operator=</a> (<a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:af0ccee59b4b2af252f5b8b6351ccdfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assignment operator  <a href="class_util_1_1_hash_table.html#af0ccee59b4b2af252f5b8b6351ccdfb2">More...</a><br /></td></tr>
<tr class="separator:af0ccee59b4b2af252f5b8b6351ccdfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57095f9018aeeca8cc7ada4bbfc9d834"><td class="memItemLeft" align="right" valign="top">VALUETYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a57095f9018aeeca8cc7ada4bbfc9d834">operator[]</a> (const KEYTYPE &amp;key) const</td></tr>
<tr class="memdesc:a57095f9018aeeca8cc7ada4bbfc9d834"><td class="mdescLeft">&#160;</td><td class="mdescRight">read/write [] operator, assertion if key not found  <a href="class_util_1_1_hash_table.html#a57095f9018aeeca8cc7ada4bbfc9d834">More...</a><br /></td></tr>
<tr class="separator:a57095f9018aeeca8cc7ada4bbfc9d834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679b7a7e7adef24aa588682086f12212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a679b7a7e7adef24aa588682086f12212">Size</a> () const</td></tr>
<tr class="memdesc:a679b7a7e7adef24aa588682086f12212"><td class="mdescLeft">&#160;</td><td class="mdescRight">return current number of values in the hashtable  <a href="class_util_1_1_hash_table.html#a679b7a7e7adef24aa588682086f12212">More...</a><br /></td></tr>
<tr class="separator:a679b7a7e7adef24aa588682086f12212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88df5789bf9352630051aaa323886149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a88df5789bf9352630051aaa323886149">Capacity</a> () const</td></tr>
<tr class="memdesc:a88df5789bf9352630051aaa323886149"><td class="mdescLeft">&#160;</td><td class="mdescRight">return fixed-size capacity of the hash table  <a href="class_util_1_1_hash_table.html#a88df5789bf9352630051aaa323886149">More...</a><br /></td></tr>
<tr class="separator:a88df5789bf9352630051aaa323886149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa9ebfff93b54119e873505098efd20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a7fa9ebfff93b54119e873505098efd20">Clear</a> ()</td></tr>
<tr class="memdesc:a7fa9ebfff93b54119e873505098efd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear the hashtable  <a href="class_util_1_1_hash_table.html#a7fa9ebfff93b54119e873505098efd20">More...</a><br /></td></tr>
<tr class="separator:a7fa9ebfff93b54119e873505098efd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4765a12c0207dca544901be78b2f140d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a4765a12c0207dca544901be78b2f140d">Reset</a> ()</td></tr>
<tr class="memdesc:a4765a12c0207dca544901be78b2f140d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the hashtable arrays to 0 size, but don't run destructor  <a href="class_util_1_1_hash_table.html#a4765a12c0207dca544901be78b2f140d">More...</a><br /></td></tr>
<tr class="separator:a4765a12c0207dca544901be78b2f140d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af17cb14cdf86de4caa637b945fdc5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a6af17cb14cdf86de4caa637b945fdc5d">IsEmpty</a> () const</td></tr>
<tr class="memdesc:a6af17cb14cdf86de4caa637b945fdc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if empty  <a href="class_util_1_1_hash_table.html#a6af17cb14cdf86de4caa637b945fdc5d">More...</a><br /></td></tr>
<tr class="separator:a6af17cb14cdf86de4caa637b945fdc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b41bb1c3bf0761dbcb8bb92448d9a80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a9b41bb1c3bf0761dbcb8bb92448d9a80">BeginBulkAdd</a> ()</td></tr>
<tr class="memdesc:a9b41bb1c3bf0761dbcb8bb92448d9a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">begin bulk adding to the hashtable, which will amortize the cost of sorting the hash buckets upon end  <a href="class_util_1_1_hash_table.html#a9b41bb1c3bf0761dbcb8bb92448d9a80">More...</a><br /></td></tr>
<tr class="separator:a9b41bb1c3bf0761dbcb8bb92448d9a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15ecebb7139bd1858aaeb81e8ce4759"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#ad15ecebb7139bd1858aaeb81e8ce4759">IsBulkAdd</a> () const</td></tr>
<tr class="memdesc:ad15ecebb7139bd1858aaeb81e8ce4759"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if currently bulk adding  <a href="class_util_1_1_hash_table.html#ad15ecebb7139bd1858aaeb81e8ce4759">More...</a><br /></td></tr>
<tr class="separator:ad15ecebb7139bd1858aaeb81e8ce4759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1f1cacadf6af16c50005b31503fa28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a5b1f1cacadf6af16c50005b31503fa28">Add</a> (const <a class="el" href="class_util_1_1_key_value_pair.html">KeyValuePair</a>&lt; KEYTYPE, VALUETYPE &gt; &amp;kvp)</td></tr>
<tr class="memdesc:a5b1f1cacadf6af16c50005b31503fa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a key/value pair object to the hash table, returns index within hash array where item is stored  <a href="class_util_1_1_hash_table.html#a5b1f1cacadf6af16c50005b31503fa28">More...</a><br /></td></tr>
<tr class="separator:a5b1f1cacadf6af16c50005b31503fa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1b2d49c3f24580e828a11891e9dc61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#afa1b2d49c3f24580e828a11891e9dc61">Add</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value)</td></tr>
<tr class="memdesc:afa1b2d49c3f24580e828a11891e9dc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a key and associated value  <a href="class_util_1_1_hash_table.html#afa1b2d49c3f24580e828a11891e9dc61">More...</a><br /></td></tr>
<tr class="separator:afa1b2d49c3f24580e828a11891e9dc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d0efd8ab1dcdb61f82b1369ad1dc7d"><td class="memItemLeft" align="right" valign="top">VALUETYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a40d0efd8ab1dcdb61f82b1369ad1dc7d">AddUnique</a> (const KEYTYPE &amp;key)</td></tr>
<tr class="memdesc:a40d0efd8ab1dcdb61f82b1369ad1dc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds element only if it doesn't exist, and return reference to it  <a href="class_util_1_1_hash_table.html#a40d0efd8ab1dcdb61f82b1369ad1dc7d">More...</a><br /></td></tr>
<tr class="separator:a40d0efd8ab1dcdb61f82b1369ad1dc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e599336fc2ff765d1c56a17cf10d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a07e599336fc2ff765d1c56a17cf10d8d">EndBulkAdd</a> ()</td></tr>
<tr class="memdesc:a07e599336fc2ff765d1c56a17cf10d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">end bulk adding, which sorts all affected tables  <a href="class_util_1_1_hash_table.html#a07e599336fc2ff765d1c56a17cf10d8d">More...</a><br /></td></tr>
<tr class="separator:a07e599336fc2ff765d1c56a17cf10d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d38c305a51c9755950f618f5314a14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#aa2d38c305a51c9755950f618f5314a14">Merge</a> (const <a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa2d38c305a51c9755950f618f5314a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge two dictionaries  <a href="class_util_1_1_hash_table.html#aa2d38c305a51c9755950f618f5314a14">More...</a><br /></td></tr>
<tr class="separator:aa2d38c305a51c9755950f618f5314a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80af7676d3d015cf4f3ec82d2bdc9864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a80af7676d3d015cf4f3ec82d2bdc9864">Erase</a> (const KEYTYPE &amp;key)</td></tr>
<tr class="memdesc:a80af7676d3d015cf4f3ec82d2bdc9864"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase an entry  <a href="class_util_1_1_hash_table.html#a80af7676d3d015cf4f3ec82d2bdc9864">More...</a><br /></td></tr>
<tr class="separator:a80af7676d3d015cf4f3ec82d2bdc9864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42e6f252e4051410d5e0fccbc974ca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#ac42e6f252e4051410d5e0fccbc974ca3">EraseIndex</a> (const KEYTYPE &amp;key, <a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> i)</td></tr>
<tr class="memdesc:ac42e6f252e4051410d5e0fccbc974ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase an entry with known index  <a href="class_util_1_1_hash_table.html#ac42e6f252e4051410d5e0fccbc974ca3">More...</a><br /></td></tr>
<tr class="separator:ac42e6f252e4051410d5e0fccbc974ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ba7a1b06b0faad12c66b5e513c7710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#ab7ba7a1b06b0faad12c66b5e513c7710">Contains</a> (const KEYTYPE &amp;key) const</td></tr>
<tr class="memdesc:ab7ba7a1b06b0faad12c66b5e513c7710"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if key exists in the array  <a href="class_util_1_1_hash_table.html#ab7ba7a1b06b0faad12c66b5e513c7710">More...</a><br /></td></tr>
<tr class="separator:ab7ba7a1b06b0faad12c66b5e513c7710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20760dd44bb1a8a2a82c4e01f923da96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a20760dd44bb1a8a2a82c4e01f923da96">FindIndex</a> (const KEYTYPE &amp;key) const</td></tr>
<tr class="memdesc:a20760dd44bb1a8a2a82c4e01f923da96"><td class="mdescLeft">&#160;</td><td class="mdescRight">find index in bucket  <a href="class_util_1_1_hash_table.html#a20760dd44bb1a8a2a82c4e01f923da96">More...</a><br /></td></tr>
<tr class="separator:a20760dd44bb1a8a2a82c4e01f923da96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553c24ed85c48c817624bc65cdcb8110"><td class="memItemLeft" align="right" valign="top">VALUETYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a553c24ed85c48c817624bc65cdcb8110">ValueAtIndex</a> (const KEYTYPE &amp;key, <a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> i) const</td></tr>
<tr class="memdesc:a553c24ed85c48c817624bc65cdcb8110"><td class="mdescLeft">&#160;</td><td class="mdescRight">get value from key and bucket  <a href="class_util_1_1_hash_table.html#a553c24ed85c48c817624bc65cdcb8110">More...</a><br /></td></tr>
<tr class="separator:a553c24ed85c48c817624bc65cdcb8110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf64aa7576f0fdc9f532f054be851419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; <a class="el" href="class_util_1_1_key_value_pair.html">KeyValuePair</a>&lt; KEYTYPE, VALUETYPE &gt;, STACK_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#adf64aa7576f0fdc9f532f054be851419">Content</a> () const</td></tr>
<tr class="memdesc:adf64aa7576f0fdc9f532f054be851419"><td class="mdescLeft">&#160;</td><td class="mdescRight">return array of all key/value pairs in the table (slow)  <a href="class_util_1_1_hash_table.html#adf64aa7576f0fdc9f532f054be851419">More...</a><br /></td></tr>
<tr class="separator:adf64aa7576f0fdc9f532f054be851419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1054d792460519e19ed69f83b419b389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; KEYTYPE, STACK_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a1054d792460519e19ed69f83b419b389">KeysAsArray</a> () const</td></tr>
<tr class="memdesc:a1054d792460519e19ed69f83b419b389"><td class="mdescLeft">&#160;</td><td class="mdescRight">get all keys as an <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Util::Array</a> (slow)  <a href="class_util_1_1_hash_table.html#a1054d792460519e19ed69f83b419b389">More...</a><br /></td></tr>
<tr class="separator:a1054d792460519e19ed69f83b419b389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e5db87d4e8fd8caae57f469dda295a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; VALUETYPE, STACK_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a62e5db87d4e8fd8caae57f469dda295a">ValuesAsArray</a> () const</td></tr>
<tr class="memdesc:a62e5db87d4e8fd8caae57f469dda295a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get all keys as an <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Util::Array</a> (slow)  <a href="class_util_1_1_hash_table.html#a62e5db87d4e8fd8caae57f469dda295a">More...</a><br /></td></tr>
<tr class="separator:a62e5db87d4e8fd8caae57f469dda295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fc52d85bb47a4191608defc3705fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_hash_table_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#ac6fc52d85bb47a4191608defc3705fa7">Begin</a> ()</td></tr>
<tr class="memdesc:ac6fc52d85bb47a4191608defc3705fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get iterator to first element  <a href="class_util_1_1_hash_table.html#ac6fc52d85bb47a4191608defc3705fa7">More...</a><br /></td></tr>
<tr class="separator:ac6fc52d85bb47a4191608defc3705fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5c65882e975097c13813298df4ef40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_hash_table_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#ade5c65882e975097c13813298df4ef40">End</a> ()</td></tr>
<tr class="memdesc:ade5c65882e975097c13813298df4ef40"><td class="mdescLeft">&#160;</td><td class="mdescRight">get iterator to last element  <a href="class_util_1_1_hash_table.html#ade5c65882e975097c13813298df4ef40">More...</a><br /></td></tr>
<tr class="separator:ade5c65882e975097c13813298df4ef40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4d8e4d5c6f4cb7615d014a5fb0840575"><td class="memTemplParams" colspan="2">template&lt;typename HASHKEY &gt; </td></tr>
<tr class="memitem:a4d8e4d5c6f4cb7615d014a5fb0840575"><td class="memTemplItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a4d8e4d5c6f4cb7615d014a5fb0840575">GetHashCode</a> (const typename std::enable_if&lt; std::is_integral&lt; HASHKEY &gt;::value, HASHKEY &gt;::type &amp;key) const</td></tr>
<tr class="memdesc:a4d8e4d5c6f4cb7615d014a5fb0840575"><td class="mdescLeft">&#160;</td><td class="mdescRight">if type is integral, just use that value directly  <a href="class_util_1_1_hash_table.html#a4d8e4d5c6f4cb7615d014a5fb0840575">More...</a><br /></td></tr>
<tr class="separator:a4d8e4d5c6f4cb7615d014a5fb0840575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b7ab4966167575c1c576e5bf183b23"><td class="memTemplParams" colspan="2">template&lt;typename HASHKEY &gt; </td></tr>
<tr class="memitem:a67b7ab4966167575c1c576e5bf183b23"><td class="memTemplItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a67b7ab4966167575c1c576e5bf183b23">GetHashCode</a> (const HASHKEY &amp;key) const</td></tr>
<tr class="memdesc:a67b7ab4966167575c1c576e5bf183b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">if not, call the function on HashCode on HASHKEY  <a href="class_util_1_1_hash_table.html#a67b7ab4966167575c1c576e5bf183b23">More...</a><br /></td></tr>
<tr class="separator:a67b7ab4966167575c1c576e5bf183b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a765b267fbbc5ba67a93a4613a4c2a"><td class="memTemplParams" colspan="2">template&lt;typename HASHKEY &gt; </td></tr>
<tr class="memitem:ad2a765b267fbbc5ba67a93a4613a4c2a"><td class="memTemplItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#ad2a765b267fbbc5ba67a93a4613a4c2a">GetHashCode</a> (const typename std::enable_if&lt; std::is_pointer&lt; HASHKEY &gt;::value, HASHKEY &gt;::type &amp;key) const</td></tr>
<tr class="memdesc:ad2a765b267fbbc5ba67a93a4613a4c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">if type is pointer, convert using questionable method  <a href="class_util_1_1_hash_table.html#ad2a765b267fbbc5ba67a93a4613a4c2a">More...</a><br /></td></tr>
<tr class="separator:ad2a765b267fbbc5ba67a93a4613a4c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6e435c7f9dfb53a75a7385095c67596b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_fixed_array.html">FixedArray</a>&lt; <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; <a class="el" href="class_util_1_1_key_value_pair.html">KeyValuePair</a>&lt; KEYTYPE, VALUETYPE &gt;, STACK_SIZE &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a6e435c7f9dfb53a75a7385095c67596b">hashArray</a></td></tr>
<tr class="separator:a6e435c7f9dfb53a75a7385095c67596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a937f3e527459af2493b54eeee94f4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a5a937f3e527459af2493b54eeee94f4c">size</a></td></tr>
<tr class="separator:a5a937f3e527459af2493b54eeee94f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499477574127bc7ee998108de83025b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_fixed_array.html">FixedArray</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#a499477574127bc7ee998108de83025b7">bulkDirty</a></td></tr>
<tr class="separator:a499477574127bc7ee998108de83025b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc6bbdc95c1f18251ef9e1268ec1e0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html#abdc6bbdc95c1f18251ef9e1268ec1e0b">inBulkAdd</a></td></tr>
<tr class="separator:abdc6bbdc95c1f18251ef9e1268ec1e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6168ec5e95041586c9f69037e90591cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6168ec5e95041586c9f69037e90591cb">&#9670;&nbsp;</a></span>HashTable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::<a class="el" href="class_util_1_1_hash_table.html">HashTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default constructor </p>

</div>
</div>
<a id="a7b47f9feddc4608cdd32c47ed96d770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b47f9feddc4608cdd32c47ed96d770c">&#9670;&nbsp;</a></span>HashTable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::<a class="el" href="class_util_1_1_hash_table.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy constructor </p>

</div>
</div>
<a id="a2338141dd260d398b004f7fe53e886b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2338141dd260d398b004f7fe53e886b6">&#9670;&nbsp;</a></span>HashTable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::<a class="el" href="class_util_1_1_hash_table.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>move constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afa1b2d49c3f24580e828a11891e9dc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1b2d49c3f24580e828a11891e9dc61">&#9670;&nbsp;</a></span>Add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Add </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a key and associated value </p>

</div>
</div>
<a id="a5b1f1cacadf6af16c50005b31503fa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1f1cacadf6af16c50005b31503fa28">&#9670;&nbsp;</a></span>Add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_key_value_pair.html">KeyValuePair</a>&lt; KEYTYPE, VALUETYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>kvp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a key/value pair object to the hash table, returns index within hash array where item is stored </p>

</div>
</div>
<a id="a40d0efd8ab1dcdb61f82b1369ad1dc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d0efd8ab1dcdb61f82b1369ad1dc7d">&#9670;&nbsp;</a></span>AddUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUETYPE &amp; <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::AddUnique </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds element only if it doesn't exist, and return reference to it </p>

</div>
</div>
<a id="ac6fc52d85bb47a4191608defc3705fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fc52d85bb47a4191608defc3705fa7">&#9670;&nbsp;</a></span>Begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::<a class="el" href="class_util_1_1_hash_table_1_1_iterator.html">Iterator</a> <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get iterator to first element </p>

</div>
</div>
<a id="a9b41bb1c3bf0761dbcb8bb92448d9a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b41bb1c3bf0761dbcb8bb92448d9a80">&#9670;&nbsp;</a></span>BeginBulkAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::BeginBulkAdd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>begin bulk adding to the hashtable, which will amortize the cost of sorting the hash buckets upon end </p>

</div>
</div>
<a id="a88df5789bf9352630051aaa323886149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88df5789bf9352630051aaa323886149">&#9670;&nbsp;</a></span>Capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return fixed-size capacity of the hash table </p>

</div>
</div>
<a id="a7fa9ebfff93b54119e873505098efd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa9ebfff93b54119e873505098efd20">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear the hashtable </p>

</div>
</div>
<a id="ab7ba7a1b06b0faad12c66b5e513c7710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ba7a1b06b0faad12c66b5e513c7710">&#9670;&nbsp;</a></span>Contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Contains </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if key exists in the array </p>

</div>
</div>
<a id="adf64aa7576f0fdc9f532f054be851419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf64aa7576f0fdc9f532f054be851419">&#9670;&nbsp;</a></span>Content()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; <a class="el" href="class_util_1_1_key_value_pair.html">KeyValuePair</a>&lt; KEYTYPE, VALUETYPE &gt;, STACK_SIZE &gt; <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Content</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return array of all key/value pairs in the table (slow) </p>

</div>
</div>
<a id="ade5c65882e975097c13813298df4ef40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5c65882e975097c13813298df4ef40">&#9670;&nbsp;</a></span>End()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::<a class="el" href="class_util_1_1_hash_table_1_1_iterator.html">Iterator</a> <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::End</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get iterator to last element </p>

</div>
</div>
<a id="a07e599336fc2ff765d1c56a17cf10d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e599336fc2ff765d1c56a17cf10d8d">&#9670;&nbsp;</a></span>EndBulkAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::EndBulkAdd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>end bulk adding, which sorts all affected tables </p>

</div>
</div>
<a id="a80af7676d3d015cf4f3ec82d2bdc9864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80af7676d3d015cf4f3ec82d2bdc9864">&#9670;&nbsp;</a></span>Erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Erase </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase an entry </p>

</div>
</div>
<a id="ac42e6f252e4051410d5e0fccbc974ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42e6f252e4051410d5e0fccbc974ca3">&#9670;&nbsp;</a></span>EraseIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::EraseIndex </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase an entry with known index </p>

</div>
</div>
<a id="a20760dd44bb1a8a2a82c4e01f923da96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20760dd44bb1a8a2a82c4e01f923da96">&#9670;&nbsp;</a></span>FindIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::FindIndex </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find index in bucket </p>

</div>
</div>
<a id="a67b7ab4966167575c1c576e5bf183b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b7ab4966167575c1c576e5bf183b23">&#9670;&nbsp;</a></span>GetHashCode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE = 128, int STACK_SIZE = 1&gt; </div>
<div class="memtemplate">
template&lt;typename HASHKEY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const HASHKEY &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if not, call the function on HashCode on HASHKEY </p>

</div>
</div>
<a id="a4d8e4d5c6f4cb7615d014a5fb0840575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8e4d5c6f4cb7615d014a5fb0840575">&#9670;&nbsp;</a></span>GetHashCode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE = 128, int STACK_SIZE = 1&gt; </div>
<div class="memtemplate">
template&lt;typename HASHKEY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const typename std::enable_if&lt; std::is_integral&lt; HASHKEY &gt;::value, HASHKEY &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if type is integral, just use that value directly </p>

</div>
</div>
<a id="ad2a765b267fbbc5ba67a93a4613a4c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a765b267fbbc5ba67a93a4613a4c2a">&#9670;&nbsp;</a></span>GetHashCode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE = 128, int STACK_SIZE = 1&gt; </div>
<div class="memtemplate">
template&lt;typename HASHKEY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const typename std::enable_if&lt; std::is_pointer&lt; HASHKEY &gt;::value, HASHKEY &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if type is pointer, convert using questionable method </p>

</div>
</div>
<a id="ad15ecebb7139bd1858aaeb81e8ce4759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15ecebb7139bd1858aaeb81e8ce4759">&#9670;&nbsp;</a></span>IsBulkAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::IsBulkAdd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if currently bulk adding </p>

</div>
</div>
<a id="a6af17cb14cdf86de4caa637b945fdc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af17cb14cdf86de4caa637b945fdc5d">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::IsEmpty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if empty </p>

</div>
</div>
<a id="a1054d792460519e19ed69f83b419b389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1054d792460519e19ed69f83b419b389">&#9670;&nbsp;</a></span>KeysAsArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; KEYTYPE, STACK_SIZE &gt; <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::KeysAsArray</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get all keys as an <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Util::Array</a> (slow) </p>

</div>
</div>
<a id="aa2d38c305a51c9755950f618f5314a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d38c305a51c9755950f618f5314a14">&#9670;&nbsp;</a></span>Merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge two dictionaries </p>

</div>
</div>
<a id="a4926e7a91bb4d52ae823ef961cda86d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4926e7a91bb4d52ae823ef961cda86d6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assignment operator </p>

</div>
</div>
<a id="af0ccee59b4b2af252f5b8b6351ccdfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ccee59b4b2af252f5b8b6351ccdfb2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_hash_table.html">HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>move assignment operator </p>

</div>
</div>
<a id="a57095f9018aeeca8cc7ada4bbfc9d834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57095f9018aeeca8cc7ada4bbfc9d834">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUETYPE &amp; <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read/write [] operator, assertion if key not found </p>

</div>
</div>
<a id="a4765a12c0207dca544901be78b2f140d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4765a12c0207dca544901be78b2f140d">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Reset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reset the hashtable arrays to 0 size, but don't run destructor </p>

</div>
</div>
<a id="a679b7a7e7adef24aa588682086f12212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679b7a7e7adef24aa588682086f12212">&#9670;&nbsp;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::Size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return current number of values in the hashtable </p>

</div>
</div>
<a id="a553c24ed85c48c817624bc65cdcb8110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553c24ed85c48c817624bc65cdcb8110">&#9670;&nbsp;</a></span>ValueAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUETYPE &amp; <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::ValueAtIndex </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get value from key and bucket </p>

</div>
</div>
<a id="a62e5db87d4e8fd8caae57f469dda295a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e5db87d4e8fd8caae57f469dda295a">&#9670;&nbsp;</a></span>ValuesAsArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE, int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; VALUETYPE, STACK_SIZE &gt; <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::ValuesAsArray</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get all keys as an <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Util::Array</a> (slow) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a499477574127bc7ee998108de83025b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499477574127bc7ee998108de83025b7">&#9670;&nbsp;</a></span>bulkDirty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE = 128, int STACK_SIZE = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_fixed_array.html">FixedArray</a>&lt;bool&gt; <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::bulkDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e435c7f9dfb53a75a7385095c67596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e435c7f9dfb53a75a7385095c67596b">&#9670;&nbsp;</a></span>hashArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE = 128, int STACK_SIZE = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_fixed_array.html">FixedArray</a>&lt;<a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt;<a class="el" href="class_util_1_1_key_value_pair.html">KeyValuePair</a>&lt;KEYTYPE, VALUETYPE&gt;, STACK_SIZE&gt; &gt; <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::hashArray</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdc6bbdc95c1f18251ef9e1268ec1e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc6bbdc95c1f18251ef9e1268ec1e0b">&#9670;&nbsp;</a></span>inBulkAdd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE = 128, int STACK_SIZE = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::inBulkAdd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a937f3e527459af2493b54eeee94f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a937f3e527459af2493b54eeee94f4c">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE , int TABLE_SIZE = 128, int STACK_SIZE = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_util_1_1_hash_table.html">Util::HashTable</a>&lt; KEYTYPE, VALUETYPE, TABLE_SIZE, STACK_SIZE &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/code/foundation/util/<a class="el" href="hashtable_8h_source.html">hashtable.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="navelem"><a class="el" href="namespace_util.html">Util</a></li><li class="navelem"><a class="el" href="class_util_1_1_hash_table.html">HashTable</a></li>
				<li class="footer">
					Generated on Sun Jan 17 2021 12:08:12 for Nebula. Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
