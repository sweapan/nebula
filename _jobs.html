<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Nebula: Jobs</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Nebula
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_jobs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespace_jobs.html" title="Job system allows for scheduling and execution of a parallel task.">Jobs</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="NebulaJobSystem"></a>
The Job System</h1>
<p>The job system implements a fire-and-forget type of thread job. The basic idea is that a programmer will want to run many different tasks with different contexts, but doesn't want to bother writing a new thread class for each of these tasks. As such, the Job system is divided into three types: <a class="el" href="struct_jobs_1_1_job_port_id.html">Jobs::JobPortId</a>, <a class="el" href="struct_jobs_1_1_job_id.html">Jobs::JobId</a>, <a class="el" href="struct_jobs_1_1_job_sync_id.html">Jobs::JobSyncId</a>. A job port is a gateway for a job, and must as such be constructed first.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_jobs_1_1_create_job_port_info.html">Jobs::CreateJobPortInfo</a> info =</div>
<div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;ExampleJobPort&quot;</span>,</div>
<div class="line">    4,</div>
<div class="line">    <a class="code" href="class_system_1_1_cpu.html#a3b8f60cd659ada1a83e8e5f72c1e6c5da9c8ddf3295926df6c3c7a177313616b5">System::Cpu::Core1</a> | <a class="code" href="class_system_1_1_cpu.html#a3b8f60cd659ada1a83e8e5f72c1e6c5dabbb98fcd01468b4d5ac063c3d70929d7">System::Cpu::Core2</a> | <a class="code" href="class_system_1_1_cpu.html#a3b8f60cd659ada1a83e8e5f72c1e6c5da2baa434922b58bc0da2426a07548653e">System::Cpu::Core3</a> | <a class="code" href="class_system_1_1_cpu.html#a3b8f60cd659ada1a83e8e5f72c1e6c5dace72b75ba389dd1d2c2acbd2a708d05e">System::Cpu::Core4</a>,</div>
<div class="line">    UINT_MAX</div>
<div class="line">};</div>
<div class="line">someJobPort = <a class="code" href="namespace_jobs.html#adb1daec4e4d880ba7121fb9fe40b9a69">CreateJobPort</a>(info);</div>
<div class="ttc" id="aclass_system_1_1_cpu_html_a3b8f60cd659ada1a83e8e5f72c1e6c5da2baa434922b58bc0da2426a07548653e"><div class="ttname"><a href="class_system_1_1_cpu.html#a3b8f60cd659ada1a83e8e5f72c1e6c5da2baa434922b58bc0da2426a07548653e">System::Cpu::Core3</a></div><div class="ttdeci">@ Core3</div><div class="ttdef"><b>Definition:</b> cpu.h:23</div></div>
<div class="ttc" id="aclass_system_1_1_cpu_html_a3b8f60cd659ada1a83e8e5f72c1e6c5da9c8ddf3295926df6c3c7a177313616b5"><div class="ttname"><a href="class_system_1_1_cpu.html#a3b8f60cd659ada1a83e8e5f72c1e6c5da9c8ddf3295926df6c3c7a177313616b5">System::Cpu::Core1</a></div><div class="ttdeci">@ Core1</div><div class="ttdef"><b>Definition:</b> cpu.h:21</div></div>
<div class="ttc" id="aclass_system_1_1_cpu_html_a3b8f60cd659ada1a83e8e5f72c1e6c5dabbb98fcd01468b4d5ac063c3d70929d7"><div class="ttname"><a href="class_system_1_1_cpu.html#a3b8f60cd659ada1a83e8e5f72c1e6c5dabbb98fcd01468b4d5ac063c3d70929d7">System::Cpu::Core2</a></div><div class="ttdeci">@ Core2</div><div class="ttdef"><b>Definition:</b> cpu.h:22</div></div>
<div class="ttc" id="aclass_system_1_1_cpu_html_a3b8f60cd659ada1a83e8e5f72c1e6c5dace72b75ba389dd1d2c2acbd2a708d05e"><div class="ttname"><a href="class_system_1_1_cpu.html#a3b8f60cd659ada1a83e8e5f72c1e6c5dace72b75ba389dd1d2c2acbd2a708d05e">System::Cpu::Core4</a></div><div class="ttdeci">@ Core4</div><div class="ttdef"><b>Definition:</b> cpu.h:24</div></div>
<div class="ttc" id="anamespace_jobs_html_adb1daec4e4d880ba7121fb9fe40b9a69"><div class="ttname"><a href="namespace_jobs.html#adb1daec4e4d880ba7121fb9fe40b9a69">Jobs::CreateJobPort</a></div><div class="ttdeci">JobPortId CreateJobPort(const CreateJobPortInfo &amp;info)</div><div class="ttdoc">create a new job port</div><div class="ttdef"><b>Definition:</b> jobs.cc:20</div></div>
<div class="ttc" id="astruct_jobs_1_1_create_job_port_info_html"><div class="ttname"><a href="struct_jobs_1_1_create_job_port_info.html">Jobs::CreateJobPortInfo</a></div><div class="ttdef"><b>Definition:</b> jobs.h:165</div></div>
</div><!-- fragment --><p>In this example, we specify a name, the amount of threads we want to use, a bit mask containing the processor cores we think this port should use, and a priority value. The port is then created and will have 4 <a class="el" href="class_threading_1_1_thread.html">Threading::Thread</a> firing and waiting for jobs. In order to queue up a job, we do the following:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_jobs_1_1_job_id.html">Jobs::JobId</a> job = <a class="code" href="namespace_jobs.html#af1a0500babaf3a835fa53d06dc9ba52e">Jobs::CreateJob</a>({ SomeLambdaFunction });</div>
<div class="line"><a class="code" href="namespace_jobs.html#a96f00b4872bd1a2c0dfb4835e72f90e7">Jobs::JobSchedule</a>(job, someJobPort, ctx, <span class="keyword">false</span>);</div>
<div class="ttc" id="anamespace_jobs_html_a96f00b4872bd1a2c0dfb4835e72f90e7"><div class="ttname"><a href="namespace_jobs.html#a96f00b4872bd1a2c0dfb4835e72f90e7">Jobs::JobSchedule</a></div><div class="ttdeci">void JobSchedule(const JobId &amp;job, const JobPortId &amp;port, const JobContext &amp;ctx, const bool cycleThreads)</div><div class="ttdoc">schedule job to be executed</div><div class="ttdef"><b>Definition:</b> jobs.cc:92</div></div>
<div class="ttc" id="anamespace_jobs_html_af1a0500babaf3a835fa53d06dc9ba52e"><div class="ttname"><a href="namespace_jobs.html#af1a0500babaf3a835fa53d06dc9ba52e">Jobs::CreateJob</a></div><div class="ttdeci">JobId CreateJob(const CreateJobInfo &amp;info)</div><div class="ttdoc">create job</div><div class="ttdef"><b>Definition:</b> jobs.cc:62</div></div>
<div class="ttc" id="astruct_jobs_1_1_job_id_html"><div class="ttname"><a href="struct_jobs_1_1_job_id.html">Jobs::JobId</a></div><div class="ttdef"><b>Definition:</b> jobs.h:160</div></div>
</div><!-- fragment --><p>This will trigger the job to run on any of the threads. In fact, how it works deeper down, is that based on the data provided to the job, the job port may chose to split the work on multiple threads in order to maximize thread occupancy.</p>
<p>If we then want to be able to wait for this job, we have to issue a synchronization event. This is done with <a class="el" href="struct_jobs_1_1_job_sync_id.html">Jobs::JobSyncId</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_jobs_1_1_create_job_sync_info.html">Jobs::CreateJobSyncInfo</a> sinfo =</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">nullptr</span></div>
<div class="line">};</div>
<div class="line">someJobSync = <a class="code" href="namespace_jobs.html#a8579448747ff5333a12a52da7e834b4a">Jobs::CreateJobSync</a>(sinfo);</div>
<div class="ttc" id="anamespace_jobs_html_a8579448747ff5333a12a52da7e834b4a"><div class="ttname"><a href="namespace_jobs.html#a8579448747ff5333a12a52da7e834b4a">Jobs::CreateJobSync</a></div><div class="ttdeci">JobSyncId CreateJobSync(const CreateJobSyncInfo &amp;info)</div><div class="ttdoc">create job sync</div><div class="ttdef"><b>Definition:</b> jobs.cc:257</div></div>
<div class="ttc" id="astruct_jobs_1_1_create_job_sync_info_html"><div class="ttname"><a href="struct_jobs_1_1_create_job_sync_info.html">Jobs::CreateJobSyncInfo</a></div><div class="ttdef"><b>Definition:</b> jobs.h:246</div></div>
</div><!-- fragment --><p>The only argument here is an optional callback function to run when this synchronization point is hit. For this example, we leave it as nullptr. To then issue and wait for a signal, we have two options:</p>
<div class="fragment"><div class="line"><a class="code" href="namespace_jobs.html#a0842e3b14dfb05dbb2dae57784c7d5a3">Jobs::JobSyncSignal</a>(someJobSync, someJobPort);</div>
<div class="line"><a class="code" href="namespace_jobs.html#ad281e9182013178a03a7877905f6c8c4">Jobs::JobSyncThreadWait</a>(someJobSync, someJobPort);</div>
<div class="line"><a class="code" href="namespace_jobs.html#adcdc562d988a436a62fe8bc9522d8721">Jobs::JobSyncHostWait</a>(someJobSync);</div>
<div class="ttc" id="anamespace_jobs_html_a0842e3b14dfb05dbb2dae57784c7d5a3"><div class="ttname"><a href="namespace_jobs.html#a0842e3b14dfb05dbb2dae57784c7d5a3">Jobs::JobSyncSignal</a></div><div class="ttdeci">void JobSyncSignal(const JobSyncId id, const JobPortId port)</div><div class="ttdoc">put job sync on port</div><div class="ttdef"><b>Definition:</b> jobs.cc:288</div></div>
<div class="ttc" id="anamespace_jobs_html_ad281e9182013178a03a7877905f6c8c4"><div class="ttname"><a href="namespace_jobs.html#ad281e9182013178a03a7877905f6c8c4">Jobs::JobSyncThreadWait</a></div><div class="ttdeci">void JobSyncThreadWait(const JobSyncId id, const JobPortId port)</div><div class="ttdoc">wait for job on thread side</div><div class="ttdef"><b>Definition:</b> jobs.cc:337</div></div>
<div class="ttc" id="anamespace_jobs_html_adcdc562d988a436a62fe8bc9522d8721"><div class="ttname"><a href="namespace_jobs.html#adcdc562d988a436a62fe8bc9522d8721">Jobs::JobSyncHostWait</a></div><div class="ttdeci">void JobSyncHostWait(const JobSyncId id)</div><div class="ttdoc">wait for job on host side</div><div class="ttdef"><b>Definition:</b> jobs.cc:326</div></div>
</div><!-- fragment --><p>First we must issue this sync primitive to be sent to the job port, otherwise we can't wait for it to arrive. Then, we can chose to either let the threads in the port syncrhonize with each other, which is done with <a class="el" href="namespace_jobs.html#ad281e9182013178a03a7877905f6c8c4" title="wait for job on thread side">Jobs::JobSyncThreadWait</a>, or we can chose to synchronize with the issuing thread, which is done with <a class="el" href="namespace_jobs.html#adcdc562d988a436a62fe8bc9522d8721" title="wait for job on host side">Jobs::JobSyncHostWait</a>. A good example to use <a class="el" href="namespace_jobs.html#ad281e9182013178a03a7877905f6c8c4" title="wait for job on thread side">Jobs::JobSyncThreadWait</a> is when you want to run two jobs after one another, but the second job requires the previous job to finish, and since the job system splits work on multiple threads, we can't guarantee that the second job will start after all previous threads have finished. Think of the space as being the time it takes to do work, now imagine it like this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_threading_1_1_thread.html">Thread</a> 1 -- Job 1 ---- Job 2</div>
<div class="line"><a class="code" href="class_threading_1_1_thread.html">Thread</a> 2 -- Job 1 -- Job 2</div>
<div class="line"><a class="code" href="class_threading_1_1_thread.html">Thread</a> 3 -- Job 1 --- Job 2</div>
<div class="line"><a class="code" href="class_threading_1_1_thread.html">Thread</a> 4 -- Job 1 ----------</div>
<div class="ttc" id="aclass_threading_1_1_thread_html"><div class="ttname"><a href="class_threading_1_1_thread.html">Thread</a></div></div>
</div><!-- fragment --><p>For Job 2 on Threads 1, 2 &amp; 3, we have to wait for Job 1 on Thread 4 to finish, because in our scenario Job 2 will need all data processed by Job 1. Therefore we need this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_threading_1_1_thread.html">Thread</a> 1 -- Job 1 ---- Sync -- Job 2</div>
<div class="line"><a class="code" href="class_threading_1_1_thread.html">Thread</a> 2 -- Job 1 -- Sync ---- Job 2</div>
<div class="line"><a class="code" href="class_threading_1_1_thread.html">Thread</a> 3 -- Job 1 --- Sync --- Job 2</div>
<div class="line"><a class="code" href="class_threading_1_1_thread.html">Thread</a> 4 -- Job 1 --- Sync --- -----</div>
</div><!-- fragment --><p>See how it aligns? That's what <a class="el" href="namespace_jobs.html#ad281e9182013178a03a7877905f6c8c4" title="wait for job on thread side">Jobs::JobSyncThreadWait</a> will do.</p>
<p>Now, <a class="el" href="namespace_jobs.html#adcdc562d988a436a62fe8bc9522d8721" title="wait for job on host side">Jobs::JobSyncHostWait</a> will just wait for all synchronization points to be reached, and it's a blocking call, meaning the invoking thread will effectively halt until all work is done. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="navelem"><a class="el" href="foundation.html">Foundation Libraries</a></li>
				<li class="footer">
					Generated on Sun Jan 17 2021 12:08:02 for Nebula. Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
