<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Nebula: $title</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Nebula
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_core.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="contents">
<div class="textblock"><h1><a class="anchor" id="NebulaCoreSystem"></a>
The Core Subsystem</h1>
<p>The Nebula <a class="el" href="namespace_core.html">Core</a> subsystem (as the name implies) implements the core concepts of Nebula which are:</p>
<ul>
<li>a RefCounted base class which implements a strong ref counting mechanism</li>
<li>a runtime type information system</li>
<li>a templated smart pointer class Ptr&lt;&gt; which manages the life time of RefCounted objects</li>
<li>a factory mechanism which allows to construct C++ objects from their string class name</li>
<li>a central Server object which setup the basic Nebula runtime environment</li>
</ul>
<h2><a class="anchor" id="NebulaObjectModel"></a>
The Object Model</h2>
<p>Nebula implements a basic object model which implements the following features on top of the C++ object model:</p>
<ul>
<li>lifetime management by refcounting and smart pointers</li>
<li>object creation by string or fourcc class identifier</li>
<li>a runtime type information system</li>
</ul>
<h2><a class="anchor" id="NebulaClassImplementation"></a>
Implementing A New Nebula Class</h2>
<p>The first decision when implementing a new class should be whether the new class should be derived from the <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> class or whether it should be a traditional C++ class. The following points should help to find the answer:</p>
<ul>
<li>if the class wants to make use of the extended Nebula object model features like refcounting, RTTI, and so forth, it must be derived from the <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> class</li>
<li>if the class is a typical small helper or utility class, like a dynamic array class, a math vector class, or something similar, it often does not make sense to derive from <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a>.</li>
<li>if the class should mainly be used to store state or data, use a struct instead.</li>
</ul>
<p>Deriving from the <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> class implies some restrictions:</p>
<ul>
<li>RefCounted-derived objects may never be created directly in the local C++ context as stack objects, since stack objects are lifetime- managed by C++ (they are destroyed when the current C++ context is left, circumventing Nebula's refcounted lifetime management completely)</li>
<li>RefCounted-derived classes only have a default constructor.</li>
<li>RefCounted-derived classes must have a virtual destructor.</li>
<li>RefCounted-derived classes must not be copied, since this would confuse the refcounting mechanism.</li>
</ul>
<p>To make use of the Nebula object model features, one needs to derive from the <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> class and annotate the new class with some additional information in the class declaration and in the header file:</p>
<p>A normal RefCounted-derived class declaration usually looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>MyNamespace</div>
<div class="line">{</div>
<div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> <a class="code" href="class_core_1_1_ref_counted.html">Core::RefCounted</a></div>
<div class="line">{</div>
<div class="line">    DeclareClass(MyClass);</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClass();</div>
<div class="line">    <span class="keyword">virtual</span> ~MyClass();</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line">RegisterClass(MyClass);</div>
<div class="ttc" id="aclass_core_1_1_ref_counted_html"><div class="ttname"><a href="class_core_1_1_ref_counted.html">Core::RefCounted</a></div><div class="ttdoc">The common base class of Nebula.</div><div class="ttdef"><b>Definition:</b> refcounted.h:37</div></div>
</div><!-- fragment --><p>Notice the DeclareClass() macro, the default constructor and the virtual destructor and the RegisterClass() macro outside of the class declaration. The DeclareClass() macro adds some minimal Nebula-specific information to the class declaration for the RTTI and factory mechanism. The DeclareClass() macro generally hides the internals of the Nebula object model from the programmer, so that (hopefully), internals of the object model can be changed without affecting existing classes. The RegisterClass() macro is optional and registers the class with the central factory object. If you know that objects of this class will never be created by string class name or fourcc code, the RegisterClass() macro can be omitted.</p>
<p>The .cc side of the class needs to contain the following Nebula specific information:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>MyNamespace</div>
<div class="line">{</div>
<div class="line">ImplementClass(MyNamespace::MyClass, <span class="stringliteral">&#39;MYCL&#39;</span>, <a class="code" href="class_core_1_1_ref_counted.html">Core::RefCounted</a>);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>The ImplementClass() macro registers the class with the RTTI mechanism, the first parameter describes the C++ class name (note that the namespace must be present here. The second parameter is the class fourcc code, which must be unique across all classes (you'll get a runtime error at application startup if two classes try to register with the same fourcc code). The third parameter is the C++ class name of the parent class. This is used by the RTTI mechanism to reconstruct the class tree.</p>
<h2><a class="anchor" id="RefCountingAndSmartPointers"></a>
RefCounting And Smart Pointers</h2>
<p>Nebula uses traditional refcounting to manage the lifetime of its objects. A templated smart pointer class Ptr&lt;&gt; exists to hide the refcounting details from the programmer. As a general rule of thumb, always use smart pointers to point to RefCounted-derived objects unless you can make sure that within a given code block, the refcount of an object will not change.</p>
<p>Smart pointers have a number of advantages over plain pointers:</p>
<ul>
<li>accessing a 0-pointer will give you an easy to debug assertion instead of a memory fault</li>
<li>you'll never have to call AddRef() or Release() on you refcounted objects (in fact if you have, there's likely something seriously wrong)</li>
<li>smart pointers work nicely in container classes, an array of smart pointers instead of plain pointers eliminates all the typical lifetime management problems; you never need to take care about releasing the objects behind the pointers, instead the array just behaves like it would contain standard C++ objects</li>
<li>with smart pointers, you generally don't need to define "object ownership" as is often the case when using plain pointers (who's responsible to delete objects, and so on...)</li>
</ul>
<p>There are also some disadvantages with smart pointers:</p>
<ul>
<li>Performance: Copying and assigning smart pointers involves calling AddRef() and/or Release() on their objects, de-referencing a smart pointer involves an assertion-check that the contained object pointer is valid. The resulting performance hit is usually neglibe, but you may have to be aware of it in inner loops.</li>
<li>Presumably dead objects still alive: Since objects managed by smart pointers are only deleted when the last client gives up ownership, objects may exist longer then intended. Often this is points to a bug. Nebula will notify you about any refcounting leaks (that is, refcounting objects that still exist at application shutdown)</li>
<li>Overuse of the RefCounted system might be a sign that your design is not data oriented. You should always consider if the object can be stack allocated and/or allocated as part of a larger allocation, instead of being allocated as an individual heap object.</li>
</ul>
<h2><a class="anchor" id="CreatingNebulaObjects"></a>
Creating Nebula Objects</h2>
<p>Nebula objects that are derived from <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> can be created in 3 different ways:</p>
<p>Directly through the static create method: </p><div class="fragment"><div class="line"><a class="code" href="class_ptr.html">Ptr&lt;MyClass&gt;</a> myObj = <a class="code" href="namespace_game_1_1_time_manager.html#a18c6aa9e2f022cec2293bc8ba843ac6f">MyClass::Create</a>();</div>
<div class="ttc" id="aclass_ptr_html"><div class="ttname"><a href="class_ptr.html">Ptr</a></div><div class="ttdoc">Nebula's smart pointer class which manages the life time of RefCounted objects.</div><div class="ttdef"><b>Definition:</b> ptr.h:38</div></div>
<div class="ttc" id="anamespace_game_1_1_time_manager_html_a18c6aa9e2f022cec2293bc8ba843ac6f"><div class="ttname"><a href="namespace_game_1_1_time_manager.html#a18c6aa9e2f022cec2293bc8ba843ac6f">Game::TimeManager::Create</a></div><div class="ttdeci">Game::ManagerAPI Create()</div><div class="ttdoc">create the singleton</div><div class="ttdef"><b>Definition:</b> timemanager.cc:62</div></div>
</div><!-- fragment --><p> The static <a class="el" href="namespace_game_1_1_time_manager.html#a18c6aa9e2f022cec2293bc8ba843ac6f" title="create the singleton">Create()</a> method is added to the class through the DeclareClass() macro described before. This is basically just syntactic sugar for the C++ operator::new(). In fact, the <a class="el" href="namespace_game_1_1_time_manager.html#a18c6aa9e2f022cec2293bc8ba843ac6f" title="create the singleton">Create()</a> method is nothing more then an inline method with a call to the new operator inside. Also note the correct use of a smart pointer to hold the new object.</p>
<p>Another way to create a Nebula method is by class name: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_core.html">Core</a>;</div>
<div class="line"><a class="code" href="class_ptr.html">Ptr&lt;MyClass&gt;</a> myObj = (MyClass*) <a class="code" href="class_core_1_1_factory.html#a7929efbcb2e9cb3d47dfa5d3122aa6d6">Factory::Instance</a>()-&gt;<a class="code" href="class_core_1_1_factory.html#af34d651240c89bcb55bd071a5822c806">Create</a>(<span class="stringliteral">&quot;MyNamespace::MyClass&quot;</span>);</div>
<div class="ttc" id="aclass_core_1_1_factory_html_a7929efbcb2e9cb3d47dfa5d3122aa6d6"><div class="ttname"><a href="class_core_1_1_factory.html#a7929efbcb2e9cb3d47dfa5d3122aa6d6">Core::Factory::Instance</a></div><div class="ttdeci">static Factory * Instance()</div><div class="ttdoc">get pointer to singleton instance (cannot use singleton.h!)</div><div class="ttdef"><b>Definition:</b> factory.cc:23</div></div>
<div class="ttc" id="aclass_core_1_1_factory_html_af34d651240c89bcb55bd071a5822c806"><div class="ttname"><a href="class_core_1_1_factory.html#af34d651240c89bcb55bd071a5822c806">Core::Factory::Create</a></div><div class="ttdeci">void * Create(const Util::String &amp;className) const</div><div class="ttdoc">create an object by class name</div><div class="ttdef"><b>Definition:</b> factory.cc:193</div></div>
<div class="ttc" id="anamespace_core_html"><div class="ttname"><a href="namespace_core.html">Core</a></div><div class="ttdef"><b>Definition:</b> coreserver.cc:10</div></div>
</div><!-- fragment --><p> Creating an object by its string class name is useful if you don't know the object class at compile time, which is usually the case when serialized objects are restored, or when some sort of scripting interface is used. Note the type cast. This is necessary because the factory <a class="el" href="namespace_game_1_1_time_manager.html#a18c6aa9e2f022cec2293bc8ba843ac6f" title="create the singleton">Create()</a> method returns a generic pointer to a <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> object.</p>
<p>A variation of the create-by-class-name method is to create the object by its class fourcc code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_core.html">Core</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_util.html">Util</a>;</div>
<div class="line"><a class="code" href="class_ptr.html">Ptr&lt;MyClass&gt;</a> myObj = (MyClass*) <a class="code" href="class_core_1_1_factory.html#a7929efbcb2e9cb3d47dfa5d3122aa6d6">Factory::Instance</a>()-&gt;<a class="code" href="class_core_1_1_factory.html#af34d651240c89bcb55bd071a5822c806">Create</a>(FourCC(<span class="stringliteral">&#39;MYCL&#39;</span>));</div>
<div class="ttc" id="anamespace_util_html"><div class="ttname"><a href="namespace_util.html">Util</a></div><div class="ttdoc">The ArrayAllocator provides a variadic list of types which is to be contained in the allocator and fe...</div><div class="ttdef"><b>Definition:</b> array.h:37</div></div>
</div><!-- fragment --><p> This method looks less intuitive, but it is often faster as create-by-name and the fourcc class identifier uses less space (4 bytes) then the string class name, which may be of advantage when objects are encoded/decoded to and from binary streams.</p>
<h2><a class="anchor" id="NebulaRTTI"></a>
The Nebula Runtime Type Information System</h2>
<p>The Nebula RTTI system gives you access to an objects class type at runtime and lets you check whether an object is the exact instance of a class, or an instance of a derived class. You can also get the class name or the class fourcc identifier directly from an object. All this functionality is implemented behind the scenes in the DeclareClass() and ImplementClass() macros. The RTTI mechanism is more efficient and easier to use then the RTTI mechanism in Nebula1 and Nebula2.</p>
<p>Here's some example code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_util.html">Util</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_core.html">Core</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check whether an object is instance of a specific class</span></div>
<div class="line"><span class="keywordflow">if</span> (myObj-&gt;IsInstanceOf(MyClass::RTTI))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// it&#39;s a MyClass object</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check whether an object is instance of a derived class</span></div>
<div class="line"><span class="keywordflow">if</span> (myObj-&gt;IsA(RefCounted::RTTI))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// it&#39;s a RefCounted instance or some RefCounted-derived instance</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get the class name of my object, this yields &quot;MyNamespace::MyClass&quot;</span></div>
<div class="line"><span class="keyword">const</span> String&amp; className = myObj-&gt;GetClassName();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get the fourcc class identifier of my object, this yields &#39;MYCL&#39;</span></div>
<div class="line"><span class="keyword">const</span> FourCC&amp; fourcc = myObj-&gt;GetClassFourCC();</div>
</div><!-- fragment --><p>You can also query the central factory object whether a given class has been registered:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_core.html">Core</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check if a class has been registered by class name</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_core_1_1_factory.html#a7929efbcb2e9cb3d47dfa5d3122aa6d6">Factory::Instance</a>()-&gt;ClassExists(<span class="stringliteral">&quot;MyNamespace::MyClass&quot;</span>))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// yep, the class exists</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check if a class has been registered by class fourcc code</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_core_1_1_factory.html#a7929efbcb2e9cb3d47dfa5d3122aa6d6">Factory::Instance</a>()-&gt;ClassExists(FourCC(<span class="stringliteral">&#39;MYCL&#39;</span>)))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// yep, the class exists</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="NebulaSingletons"></a>
Nebula Singletons</h2>
<p>Many central Nebula objects are singletons, that is, an object which only exists once in the application and often is known to all other objects in the application.</p>
<p>Access to singleton objects can be gained through the static Instance() method, which returns a pointer to the single instance of the singleton class. The returned pointer is guaranteed to be valid. If the singleton object doesn't exist at the time the Instance() method is called, an assertion will be thrown:</p>
<div class="fragment"><div class="line"><span class="comment">// obtain a pointer to the Core::Server singleton</span></div>
<div class="line"><a class="code" href="class_ptr.html">Ptr&lt;Core::Server&gt;</a> coreServer = Core::Server::Instance();</div>
</div><!-- fragment --><p>You can also check for the existance of a given singleton: </p><div class="fragment"><div class="line"><span class="comment">// does the Core::Server object exist?</span></div>
<div class="line"><span class="keywordflow">if</span> (Core::Server::HasInstance())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// yep, the core server exists</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Nebula provides some helper macros to implement a singleton class:</p>
<div class="fragment"><div class="line"><span class="comment">// declare a singleton class</span></div>
<div class="line"><span class="keyword">class </span>MySingletonClass : <span class="keyword">public</span> <a class="code" href="class_core_1_1_ref_counted.html">Core::RefCounted</a></div>
<div class="line">{</div>
<div class="line">    DeclareClass(MySingletonClass);</div>
<div class="line">    DeclareSingleton(MySingletonClass);</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MySingletonClass();</div>
<div class="line">    <span class="keyword">virtual</span> ~MySingletonClass();</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// implement the singleton class</span></div>
<div class="line">ImplementClass(MyNamespace::MySingletonClass, <span class="stringliteral">&#39;MYSC&#39;</span>, <a class="code" href="class_core_1_1_ref_counted.html">Core::RefCounted</a>);</div>
<div class="line">ImplementSingleton(MyNamespace::MySingletonClass);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span>MySingletonClass::MySingletonClass()</div>
<div class="line">{</div>
<div class="line">    ConstructSingleton;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span>MySingletonClass:~MySingletonClass()</div>
<div class="line">{</div>
<div class="line">    DestructSingleton;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The DeclareSingleton() and ImplementSingleton() macros are similar to the DeclareClass() and ImplementClass() macros. They add some static methods to the class (namely the Instance() and HasInstance() methods). The constructor and destructor of the class must contain a <b>ConstructSingleton</b> and <b>DestructSingleton</b> macros. ConstructSingleton initializes a private static singleton pointer and makes sure that no other instance of the class exists (otherwise, an assertion will be thrown). DestructSingleton invalidates the static singleton pointer.</p>
<p>Access to singletons is by default thread-local. This means that a singleton created in one thread of a Nebula application isn't accessible from another thread.</p>
<h2><a class="anchor" id="CorePerfAndMemConsideratins"></a>
Performance And Memory Footprint Considerations</h2>
<p>One of the design goals of the Nebula <a class="el" href="namespace_core.html">Core</a> Layer was to reduce the memory footprint of low level code to make the system better suited for small host platforms like handheld consoles (and a small memory footprint doesn't hurt on bigger platforms either). Here are some points how these goals are accomplished:</p>
<ul>
<li>The RefCounted class just adds 4 bytes per-instance data for the reference count member, Nebula2's nRoot class added &gt;60 bytes overhead to each instance.</li>
<li>The RTTI mechanism adds somewhere between 30 and 60 bytes overhead, but this is per-class, not per instance.</li>
<li>A smart pointer is just the size of a regular pointer, just like a raw pointer. The similar Nebula2 nRef class was 16 bytes per instance.</li>
<li>Several householding structures are only allocated in debug mode, most notably the RefCountedList, which is used to detect refcounting leaks.</li>
</ul>
<p>Here are some timings for creating a million RefCounted objects by the 3 different ways. These timings are on a notebook with Intel Pentium M running at 800 MHz:</p>
<ul>
<li><a class="el" href="namespace_game_1_1_time_manager.html#a18c6aa9e2f022cec2293bc8ba843ac6f" title="create the singleton">Create()</a>: 0.29 seconds</li>
<li>by FourCC: 0.65 seconds</li>
<li>by class name: 1.45 seconds </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="navelem"><a class="el" href="foundation.html">Foundation Libraries</a></li>
				<li class="footer">
					Generated on Sat Jan 16 2021 22:43:49 for Nebula. Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
