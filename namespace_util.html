<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Nebula: Util Namespace Reference</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Nebula
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tuple helper functions and typedefs. </p>
<p>@function TypePunning</p>
<dl class="section copyright"><dt>Copyright</dt><dd>(C) 2018-2020 Individual contributors, see AUTHORS file</dd></dl>
<p>Function to implement type-punning, explanation here: <a href="http://mail-index.netbsd.org/tech-kern/2003/08/11/0001.html">http://mail-index.netbsd.org/tech-kern/2003/08/11/0001.html</a> <a href="http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Optimize-Options.html#Optimize-Options">http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Optimize-Options.html#Optimize-Options</a></p>
<dl class="section copyright"><dt>Copyright</dt><dd>(C) 2009 Radon Labs GmbH (C) 2013-2020 Individual contributors, see AUTHORS file </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nebula's dynamic array class.  <a href="class_util_1_1_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_array_allocator.html">ArrayAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_util_1_1_array_allocator.html" title="The ArrayAllocator provides a variadic list of types which is to be contained in the allocator and fe...">ArrayAllocator</a> provides a variadic list of types which is to be contained in the allocator and fetching each value by providing the index into the list of types, which means the members are nameless.  <a href="class_util_1_1_array_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1_allocator_lock.html">AllocatorLock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_array_allocator_safe.html">ArrayAllocatorSafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_util_1_1_array_allocator_safe.html" title="The ArrayAllocatorSafe provides a thread safe variadic list of types which is to be contained in the ...">ArrayAllocatorSafe</a> provides a thread safe variadic list of types which is to be contained in the allocator and fetching each value by providing the index into the list of types, which means the members are nameless.  <a href="class_util_1_1_array_allocator_safe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_array_queue.html">ArrayQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nebula's small vector optimized array.  <a href="class_util_1_1_array_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_bit_field.html">BitField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements large bit field.  <a href="class_util_1_1_bit_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_blob.html">Blob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_util_1_1_blob.html" title="The Util::Blob class encapsulates a chunk of raw memory into a C++ object which can be copied,...">Util::Blob</a> class encapsulates a chunk of raw memory into a C++ object which can be copied, compared and hashed.  <a href="class_util_1_1_blob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_command_line_args.html">CommandLineArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A universal cmd line argument parser.  <a href="class_util_1_1_command_line_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_crc.html">Crc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute CRC checksums over a range of memory.  <a href="class_util_1_1_crc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_delegate.html">Delegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nebula delegate class, allows to store a function, method or lambda call into a C++ object for later execution.  <a href="class_util_1_1_delegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_delegate_3_01_r_e_t_t_y_p_e_07_a_r_g_t_y_p_e_s_8_8_8_08_4.html">Delegate&lt; RETTYPE(ARGTYPES...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_dictionary.html">Dictionary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of key/value pairs with quick value retrieval by key at roughly O(log n).  <a href="class_util_1_1_dictionary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_fixed_array.html">FixedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a fixed size one-dimensional array.  <a href="class_util_1_1_fixed_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_fixed_pool.html">FixedPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a fixed size pool, from which objects of a specific type can be allocated and freed for reuse.  <a href="class_util_1_1_fixed_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_fixed_table.html">FixedTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size 2-dimensional array.  <a href="class_util_1_1_fixed_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_four_c_c.html">FourCC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A four-character-code is a quasi-human-readable 32-bit-id.  <a href="class_util_1_1_four_c_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_global_string_atom_table.html">GlobalStringAtomTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global string atom table.  <a href="class_util_1_1_global_string_atom_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_hash_table.html">HashTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Organizes key/value pairs by a hash code.  <a href="class_util_1_1_hash_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_key_value_pair.html">KeyValuePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key/Value pair objects are used by most assiociative container classes, like <a class="el" href="class_util_1_1_dictionary.html" title="A collection of key/value pairs with quick value retrieval by key at roughly O(log n).">Dictionary</a> or <a class="el" href="class_util_1_1_hash_table.html" title="Organizes key/value pairs by a hash code.">HashTable</a>.  <a href="class_util_1_1_key_value_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_list.html">List</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a doubly linked list.  <a href="class_util_1_1_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_local_string_atom_table.html">LocalStringAtomTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a thread-local string atom table which is used as a cache to prevent excessive locking when creating string atoms.  <a href="class_util_1_1_local_string_atom_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_priority_array.html">PriorityArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_quad_tree.html">QuadTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_queue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nebula's queue class (a FIFO container).  <a href="class_util_1_1_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_random_number_table.html">RandomNumberTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table-based random-number generator.  <a href="class_util_1_1_random_number_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_ring_buffer.html">RingBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ring buffer stores up to a maximum number of elements in a circular fashion.  <a href="class_util_1_1_ring_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_round.html">Round</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_run_length_codec.html">RunLengthCodec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple byte-based runlength encoder/decoder.  <a href="class_util_1_1_run_length_codec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_set.html">Set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of unique values with quick lookup.  <a href="class_util_1_1_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_simple_tree.html">SimpleTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple tree class which stores its nodes in Util::Arrays.  <a href="class_util_1_1_simple_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_sparse_table.html">SparseTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D sparse table where many entries may be redundant and support for multiple entries per cell.  <a href="class_util_1_1_sparse_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_stack.html">Stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nebula's stack class (a FILO container).  <a href="class_util_1_1_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_string.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nebula's universal string class.  <a href="class_util_1_1_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_string_atom.html">StringAtom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_util_1_1_string_atom.html" title="A StringAtom.">StringAtom</a>.  <a href="class_util_1_1_string_atom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_string_atom_table_base.html">StringAtomTableBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the base class for thread-local and global string atom table classes.  <a href="class_util_1_1_string_atom_table_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_string_buffer.html">StringBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global string buffer for the <a class="el" href="class_util_1_1_string_atom.html" title="A StringAtom.">StringAtom</a> system.  <a href="class_util_1_1_string_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_trivial_array.html">TrivialArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Array</a> class based on <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Util::Array</a> for trivial and POD types that avoids any per element copying and constructor/destructor calls.  <a href="class_util_1_1_trivial_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type.html">get_template_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type_3_01_c_3_01_t_01_4_01_4.html">get_template_type&lt; C&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of two types.  <a href="struct_util_1_1get__template__type_3_01_c_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type_3_01const_01_c_3_01_t_01_4_01_6_01_4.html">get_template_type&lt; const C&lt; T &gt; &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of a constant ref outer type.  <a href="struct_util_1_1get__template__type_3_01const_01_c_3_01_t_01_4_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_variant.html">Variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An "any type" variable.  <a href="class_util_1_1_variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a825706b32bf6453b12fa0ee6b23f3c0a"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a825706b32bf6453b12fa0ee6b23f3c0a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a825706b32bf6453b12fa0ee6b23f3c0a">Tuple</a> = std::tuple&lt; T... &gt;</td></tr>
<tr class="memdesc:a825706b32bf6453b12fa0ee6b23f3c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap std::tuple.  <a href="namespace_util.html#a825706b32bf6453b12fa0ee6b23f3c0a">More...</a><br /></td></tr>
<tr class="separator:a825706b32bf6453b12fa0ee6b23f3c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb76d79dd0028154ff80d514ec0a66cc"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:afb76d79dd0028154ff80d514ec0a66cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#afb76d79dd0028154ff80d514ec0a66cc">Pair</a> = std::pair&lt; A, B &gt;</td></tr>
<tr class="memdesc:afb76d79dd0028154ff80d514ec0a66cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap std::pair.  <a href="namespace_util.html#afb76d79dd0028154ff80d514ec0a66cc">More...</a><br /></td></tr>
<tr class="separator:afb76d79dd0028154ff80d514ec0a66cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2827363ca08e6877a2389395e69f1d34"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a2827363ca08e6877a2389395e69f1d34"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a2827363ca08e6877a2389395e69f1d34">get_template_type_t</a> = typename <a class="el" href="struct_util_1_1get__template__type.html">get_template_type</a>&lt; C &gt;::type</td></tr>
<tr class="memdesc:a2827363ca08e6877a2389395e69f1d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper typedef so that the above expression can be used like decltype.  <a href="namespace_util.html#a2827363ca08e6877a2389395e69f1d34">More...</a><br /></td></tr>
<tr class="separator:a2827363ca08e6877a2389395e69f1d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643c93045063004fd71f71b9ab650116"><td class="memTemplParams" colspan="2">template&lt;int MEMBER, class ... TYPES&gt; </td></tr>
<tr class="memitem:a643c93045063004fd71f71b9ab650116"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a643c93045063004fd71f71b9ab650116">tuple_array_t</a> = <a class="el" href="namespace_util.html#a2827363ca08e6877a2389395e69f1d34">get_template_type_t</a>&lt; std::tuple_element_t&lt; MEMBER, std::tuple&lt; <a class="el" href="class_util_1_1_array.html">Util::Array</a>&lt; TYPES &gt;... &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a643c93045063004fd71f71b9ab650116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of contained element in <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Util::Array</a> stored in std::tuple.  <a href="namespace_util.html#a643c93045063004fd71f71b9ab650116">More...</a><br /></td></tr>
<tr class="separator:a643c93045063004fd71f71b9ab650116"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a32469c5919e2ef24ec6de1835eb11804"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a32469c5919e2ef24ec6de1835eb11804">SetBit</a> (<a class="el" href="types_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:a32469c5919e2ef24ec6de1835eb11804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c94977ecc1a4eacc0fe8a31e3703f56"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a5c94977ecc1a4eacc0fe8a31e3703f56">HasBit</a> (<a class="el" href="types_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:a5c94977ecc1a4eacc0fe8a31e3703f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace97aafdb9dec71c7d94958dbaa65d97"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#ace97aafdb9dec71c7d94958dbaa65d97">SetBit</a> (<a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:ace97aafdb9dec71c7d94958dbaa65d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559a7a7139fa77cbf28c620a97aa614e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a559a7a7139fa77cbf28c620a97aa614e">HasBit</a> (<a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:a559a7a7139fa77cbf28c620a97aa614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41151ea39925673ec5f223a7eacf520"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8h.html#ac2a9e79eb120216f855626495b7bd18a">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#ab41151ea39925673ec5f223a7eacf520">SetBit</a> (<a class="el" href="types_8h.html#ac2a9e79eb120216f855626495b7bd18a">uint16</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:ab41151ea39925673ec5f223a7eacf520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7d7177fb7c733ce2a4bac52d61e7dc"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#adc7d7177fb7c733ce2a4bac52d61e7dc">HasBit</a> (<a class="el" href="types_8h.html#ac2a9e79eb120216f855626495b7bd18a">uint16</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:adc7d7177fb7c733ce2a4bac52d61e7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73ad094ccb945cb6cfa59b8b9a1a7b1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#aa73ad094ccb945cb6cfa59b8b9a1a7b1">SetBit</a> (<a class="el" href="types_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:aa73ad094ccb945cb6cfa59b8b9a1a7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6f87de2965e1bd5ccf45f48c14ef29"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#abf6f87de2965e1bd5ccf45f48c14ef29">HasBit</a> (<a class="el" href="types_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:abf6f87de2965e1bd5ccf45f48c14ef29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a86c99896c2a818350b124592d5867c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a2a86c99896c2a818350b124592d5867c">SetBit</a> (<a class="el" href="types_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:a2a86c99896c2a818350b124592d5867c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865e97c189979f35eaedc69446db24ff"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a865e97c189979f35eaedc69446db24ff">HasBit</a> (<a class="el" href="types_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:a865e97c189979f35eaedc69446db24ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcadd541631cff951e1856ea4ae5906"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8h.html#aa0d0fdc87fd135ef2bedb030901cdb9c">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#adbcadd541631cff951e1856ea4ae5906">SetBit</a> (<a class="el" href="types_8h.html#aa0d0fdc87fd135ef2bedb030901cdb9c">int16</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:adbcadd541631cff951e1856ea4ae5906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79c549d8ff8d445ac5f1da15fb8fbf1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#ad79c549d8ff8d445ac5f1da15fb8fbf1">HasBit</a> (<a class="el" href="types_8h.html#aa0d0fdc87fd135ef2bedb030901cdb9c">int16</a> mask, <a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> bit)</td></tr>
<tr class="separator:ad79c549d8ff8d445ac5f1da15fb8fbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae530f444bfb138d60bb349da54c370fc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#ae530f444bfb138d60bb349da54c370fc">CountBits</a> (<a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> i)</td></tr>
<tr class="separator:ae530f444bfb138d60bb349da54c370fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae1584667288e11bb603d2a97f8f3b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a3ae1584667288e11bb603d2a97f8f3b5">__ImplementInterfaceSingleton</a> (<a class="el" href="class_util_1_1_global_string_atom_table.html">Util::GlobalStringAtomTable</a>)</td></tr>
<tr class="separator:a3ae1584667288e11bb603d2a97f8f3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34088cd8354fbb1c5ba2201b7b7b766a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a34088cd8354fbb1c5ba2201b7b7b766a">__ImplementSingleton</a> (<a class="el" href="class_util_1_1_local_string_atom_table.html">Util::LocalStringAtomTable</a>)</td></tr>
<tr class="separator:a34088cd8354fbb1c5ba2201b7b7b766a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2638a959006c26586a1cfe736b69a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#aab2638a959006c26586a1cfe736b69a2">FastRandom</a> ()</td></tr>
<tr class="memdesc:aab2638a959006c26586a1cfe736b69a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">XorShift128 implementation.  <a href="namespace_util.html#aab2638a959006c26586a1cfe736b69a2">More...</a><br /></td></tr>
<tr class="separator:aab2638a959006c26586a1cfe736b69a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae237b3ce33a6eea3f5e7c7155b48f545"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#ae237b3ce33a6eea3f5e7c7155b48f545">RandomFloat</a> ()</td></tr>
<tr class="memdesc:ae237b3ce33a6eea3f5e7c7155b48f545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thanks to Nic Werneck (<a href="https://xor0110.wordpress.com/2010/09/24/how-to-generate-floating-point-random-numbers-efficiently/">https://xor0110.wordpress.com/2010/09/24/how-to-generate-floating-point-random-numbers-efficiently/</a>)  <a href="namespace_util.html#ae237b3ce33a6eea3f5e7c7155b48f545">More...</a><br /></td></tr>
<tr class="separator:ae237b3ce33a6eea3f5e7c7155b48f545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642cdeaf4c99cb9df42f40f245c6f07e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a642cdeaf4c99cb9df42f40f245c6f07e">RandomFloatNTP</a> ()</td></tr>
<tr class="memdesc:a642cdeaf4c99cb9df42f40f245c6f07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces an xorshift128 psuedo based floating point random number in range -1..1 Note that this is not a truely random random number generator.  <a href="namespace_util.html#a642cdeaf4c99cb9df42f40f245c6f07e">More...</a><br /></td></tr>
<tr class="separator:a642cdeaf4c99cb9df42f40f245c6f07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c53e59acf6085a3bd071283e548502"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a52c53e59acf6085a3bd071283e548502">operator==</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;a, const <a class="el" href="class_util_1_1_string.html">String</a> &amp;b)</td></tr>
<tr class="separator:a52c53e59acf6085a3bd071283e548502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f22d08ff1e974fc94153df15f4ea8a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a7f22d08ff1e974fc94153df15f4ea8a2">operator==</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;a, const char *cStr)</td></tr>
<tr class="separator:a7f22d08ff1e974fc94153df15f4ea8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5220ff5ebe65356ed98db0456a08d95c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a5220ff5ebe65356ed98db0456a08d95c">operator==</a> (const char *cStr, const <a class="el" href="class_util_1_1_string.html">String</a> &amp;b)</td></tr>
<tr class="separator:a5220ff5ebe65356ed98db0456a08d95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1be39e33c1bbdecfba94647576ff4e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#ae1be39e33c1bbdecfba94647576ff4e7">operator==</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;a, std::nullptr_t)</td></tr>
<tr class="separator:ae1be39e33c1bbdecfba94647576ff4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811c01affad2fa10d98f73a902289b73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a811c01affad2fa10d98f73a902289b73">operator!=</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;a, const <a class="el" href="class_util_1_1_string.html">String</a> &amp;b)</td></tr>
<tr class="separator:a811c01affad2fa10d98f73a902289b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4081eb1dbd288fad7d8311cb8a967aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a4081eb1dbd288fad7d8311cb8a967aee">operator&lt;</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;a, const <a class="el" href="class_util_1_1_string.html">String</a> &amp;b)</td></tr>
<tr class="separator:a4081eb1dbd288fad7d8311cb8a967aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60eccfe902320c6a743e610a663bf11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#ac60eccfe902320c6a743e610a663bf11">operator&gt;</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;a, const <a class="el" href="class_util_1_1_string.html">String</a> &amp;b)</td></tr>
<tr class="separator:ac60eccfe902320c6a743e610a663bf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85738a75813ca34d463fa88bebb5c4b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a85738a75813ca34d463fa88bebb5c4b4">operator&lt;=</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;a, const <a class="el" href="class_util_1_1_string.html">String</a> &amp;b)</td></tr>
<tr class="separator:a85738a75813ca34d463fa88bebb5c4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb507d0aacae89adff6e5bf5fbf30c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#aacb507d0aacae89adff6e5bf5fbf30c4">operator&gt;=</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;a, const <a class="el" href="class_util_1_1_string.html">String</a> &amp;b)</td></tr>
<tr class="separator:aacb507d0aacae89adff6e5bf5fbf30c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611a1b2a9424f63b0efeb85caf1eaa54"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_util_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a611a1b2a9424f63b0efeb85caf1eaa54">operator+</a> (const <a class="el" href="class_util_1_1_string.html">String</a> &amp;s0, const <a class="el" href="class_util_1_1_string.html">String</a> &amp;s1)</td></tr>
<tr class="separator:a611a1b2a9424f63b0efeb85caf1eaa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d8c93260d46c4231ebc583319a3fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_string_atom.html">Util::StringAtom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html#a00d8c93260d46c4231ebc583319a3fb6">operator&quot;&quot;_atm</a> (const char *c)</td></tr>
<tr class="separator:a00d8c93260d46c4231ebc583319a3fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20944172f5cd56d5812e38af506d25c"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:af20944172f5cd56d5812e38af506d25c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_util.html#a825706b32bf6453b12fa0ee6b23f3c0a">Tuple</a>&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#af20944172f5cd56d5812e38af506d25c">MakeTuple</a> (const T &amp;... args)</td></tr>
<tr class="separator:af20944172f5cd56d5812e38af506d25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2472a8937bb807d50a59957c5a1953a"><td class="memTemplParams" colspan="2">template&lt;int INDEX, typename... T&gt; </td></tr>
<tr class="memitem:ab2472a8937bb807d50a59957c5a1953a"><td class="memTemplItemLeft" align="right" valign="top">constexpr const std::tuple_element_t&lt; INDEX, std::tuple&lt; T... &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ab2472a8937bb807d50a59957c5a1953a">Get</a> (const <a class="el" href="namespace_util.html#a825706b32bf6453b12fa0ee6b23f3c0a">Tuple</a>&lt; T... &gt; &amp;tuple)</td></tr>
<tr class="separator:ab2472a8937bb807d50a59957c5a1953a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b170e1e4792aa7e49d7882c77e6b6a4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a1b170e1e4792aa7e49d7882c77e6b6a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_util.html#afb76d79dd0028154ff80d514ec0a66cc">Pair</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a1b170e1e4792aa7e49d7882c77e6b6a4">MakePair</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="separator:a1b170e1e4792aa7e49d7882c77e6b6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f4a027212bb08db80e683d32bba73a"><td class="memTemplParams" colspan="2">template&lt;int INDEX, typename A , typename B &gt; </td></tr>
<tr class="memitem:ad1f4a027212bb08db80e683d32bba73a"><td class="memTemplItemLeft" align="right" valign="top">constexpr const std::tuple_element_t&lt; INDEX, std::tuple&lt; A, B &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ad1f4a027212bb08db80e683d32bba73a">Get</a> (const <a class="el" href="namespace_util.html#afb76d79dd0028154ff80d514ec0a66cc">Pair</a>&lt; A, B &gt; &amp;pair)</td></tr>
<tr class="separator:ad1f4a027212bb08db80e683d32bba73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3158c18bad3c53f6b28e106254d1bd99"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a3158c18bad3c53f6b28e106254d1bd99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a3158c18bad3c53f6b28e106254d1bd99">alloc_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a3158c18bad3c53f6b28e106254d1bd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks allocations for each member in a tuble.  <a href="namespace_util.html#a3158c18bad3c53f6b28e106254d1bd99">More...</a><br /></td></tr>
<tr class="separator:a3158c18bad3c53f6b28e106254d1bd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cff58ce5395906b4582f60064540e9d"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a3cff58ce5395906b4582f60064540e9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a3cff58ce5395906b4582f60064540e9d">alloc_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a3cff58ce5395906b4582f60064540e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for above expansion function.  <a href="namespace_util.html#a3cff58ce5395906b4582f60064540e9d">More...</a><br /></td></tr>
<tr class="separator:a3cff58ce5395906b4582f60064540e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ba272acc88b6fd748bbb8a87898e26"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a33ba272acc88b6fd748bbb8a87898e26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a33ba272acc88b6fd748bbb8a87898e26">clear_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a33ba272acc88b6fd748bbb8a87898e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks allocations for each member in a tuple.  <a href="namespace_util.html#a33ba272acc88b6fd748bbb8a87898e26">More...</a><br /></td></tr>
<tr class="separator:a33ba272acc88b6fd748bbb8a87898e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac523806fb17029f288ac10791bbc7b00"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:ac523806fb17029f288ac10791bbc7b00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ac523806fb17029f288ac10791bbc7b00">clear_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:ac523806fb17029f288ac10791bbc7b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for above expansion function.  <a href="namespace_util.html#ac523806fb17029f288ac10791bbc7b00">More...</a><br /></td></tr>
<tr class="separator:ac523806fb17029f288ac10791bbc7b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7a31bf982926a6211fe93fd169da5e"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a0b7a31bf982926a6211fe93fd169da5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a0b7a31bf982926a6211fe93fd169da5e">move_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t to, uint32_t from, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a0b7a31bf982926a6211fe93fd169da5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for moving an element between two indices.  <a href="namespace_util.html#a0b7a31bf982926a6211fe93fd169da5e">More...</a><br /></td></tr>
<tr class="separator:a0b7a31bf982926a6211fe93fd169da5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bc91449daa6b35f6afdee2077e970d"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:ae6bc91449daa6b35f6afdee2077e970d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ae6bc91449daa6b35f6afdee2077e970d">move_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t to, uint32_t from)</td></tr>
<tr class="memdesc:ae6bc91449daa6b35f6afdee2077e970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for moving an element between two indices.  <a href="namespace_util.html#ae6bc91449daa6b35f6afdee2077e970d">More...</a><br /></td></tr>
<tr class="separator:ae6bc91449daa6b35f6afdee2077e970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f16fd3a8fda426003a736f5271eb9"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a168f16fd3a8fda426003a736f5271eb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a168f16fd3a8fda426003a736f5271eb9">erase_index_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a168f16fd3a8fda426003a736f5271eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing an element.  <a href="namespace_util.html#a168f16fd3a8fda426003a736f5271eb9">More...</a><br /></td></tr>
<tr class="separator:a168f16fd3a8fda426003a736f5271eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75aaffc78fa4b60acc0eab3048a67a1"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:af75aaffc78fa4b60acc0eab3048a67a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#af75aaffc78fa4b60acc0eab3048a67a1">erase_index_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i)</td></tr>
<tr class="memdesc:af75aaffc78fa4b60acc0eab3048a67a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing an element.  <a href="namespace_util.html#af75aaffc78fa4b60acc0eab3048a67a1">More...</a><br /></td></tr>
<tr class="separator:af75aaffc78fa4b60acc0eab3048a67a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2694582e9f28c42d2a9a232f0b5ecb3"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:ad2694582e9f28c42d2a9a232f0b5ecb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ad2694582e9f28c42d2a9a232f0b5ecb3">erase_index_swap_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:ad2694582e9f28c42d2a9a232f0b5ecb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing an element by swapping with the last and reducing size.  <a href="namespace_util.html#ad2694582e9f28c42d2a9a232f0b5ecb3">More...</a><br /></td></tr>
<tr class="separator:ad2694582e9f28c42d2a9a232f0b5ecb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf36a01a5e4d697e89d1e9c96a333ac"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:aabf36a01a5e4d697e89d1e9c96a333ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#aabf36a01a5e4d697e89d1e9c96a333ac">erase_index_swap_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i)</td></tr>
<tr class="memdesc:aabf36a01a5e4d697e89d1e9c96a333ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing an element by swapping with the last and reducing size.  <a href="namespace_util.html#aabf36a01a5e4d697e89d1e9c96a333ac">More...</a><br /></td></tr>
<tr class="separator:aabf36a01a5e4d697e89d1e9c96a333ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc7f181637b51cb64ae41b54c94990d"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a0cc7f181637b51cb64ae41b54c94990d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a0cc7f181637b51cb64ae41b54c94990d">erase_range_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t start, uint32_t end, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a0cc7f181637b51cb64ae41b54c94990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b9c095e9e62c3bdb32ba0f821d40ce"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:ad7b9c095e9e62c3bdb32ba0f821d40ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ad7b9c095e9e62c3bdb32ba0f821d40ce">erase_range_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t start, uint32_t end)</td></tr>
<tr class="memdesc:ad7b9c095e9e62c3bdb32ba0f821d40ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing a range of elements the last and reducing size.  <a href="namespace_util.html#ad7b9c095e9e62c3bdb32ba0f821d40ce">More...</a><br /></td></tr>
<tr class="separator:ad7b9c095e9e62c3bdb32ba0f821d40ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9f61b2d8d27bd199cf5d9b3b7902c4"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is, class... TYPES&gt; </td></tr>
<tr class="memitem:a6b9f61b2d8d27bd199cf5d9b3b7902c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a6b9f61b2d8d27bd199cf5d9b3b7902c4">set_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i, std::index_sequence&lt; Is... &gt;, TYPES const &amp;... values)</td></tr>
<tr class="memdesc:a6b9f61b2d8d27bd199cf5d9b3b7902c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for setting values in each array at an index.  <a href="namespace_util.html#a6b9f61b2d8d27bd199cf5d9b3b7902c4">More...</a><br /></td></tr>
<tr class="separator:a6b9f61b2d8d27bd199cf5d9b3b7902c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ee071178937aed8148ce1b5fb46ea7"><td class="memTemplParams" colspan="2">template&lt;class... Ts, class... TYPES&gt; </td></tr>
<tr class="memitem:a62ee071178937aed8148ce1b5fb46ea7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a62ee071178937aed8148ce1b5fb46ea7">set_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i, TYPES const &amp;... values)</td></tr>
<tr class="memdesc:a62ee071178937aed8148ce1b5fb46ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for setting values in each array at an index.  <a href="namespace_util.html#a62ee071178937aed8148ce1b5fb46ea7">More...</a><br /></td></tr>
<tr class="separator:a62ee071178937aed8148ce1b5fb46ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249e9aa97205b1b12c17aefd3b07df65"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a249e9aa97205b1b12c17aefd3b07df65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a249e9aa97205b1b12c17aefd3b07df65">reserve_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t size, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a249e9aa97205b1b12c17aefd3b07df65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for reserving in each array.  <a href="namespace_util.html#a249e9aa97205b1b12c17aefd3b07df65">More...</a><br /></td></tr>
<tr class="separator:a249e9aa97205b1b12c17aefd3b07df65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804384bbbdcd9f697e89b2bc86b15fba"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a804384bbbdcd9f697e89b2bc86b15fba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a804384bbbdcd9f697e89b2bc86b15fba">reserve_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t size)</td></tr>
<tr class="memdesc:a804384bbbdcd9f697e89b2bc86b15fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for reserving in each array.  <a href="namespace_util.html#a804384bbbdcd9f697e89b2bc86b15fba">More...</a><br /></td></tr>
<tr class="separator:a804384bbbdcd9f697e89b2bc86b15fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e576da37feb940e959259ba7751d2"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:adb0e576da37feb940e959259ba7751d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#adb0e576da37feb940e959259ba7751d2">set_size_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t size, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:adb0e576da37feb940e959259ba7751d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for reserving in each array.  <a href="namespace_util.html#adb0e576da37feb940e959259ba7751d2">More...</a><br /></td></tr>
<tr class="separator:adb0e576da37feb940e959259ba7751d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c334f60eb2cdfdf2e9272804e012a34"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a0c334f60eb2cdfdf2e9272804e012a34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a0c334f60eb2cdfdf2e9272804e012a34">set_size_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t size)</td></tr>
<tr class="memdesc:a0c334f60eb2cdfdf2e9272804e012a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for reserving in each array.  <a href="namespace_util.html#a0c334f60eb2cdfdf2e9272804e012a34">More...</a><br /></td></tr>
<tr class="separator:a0c334f60eb2cdfdf2e9272804e012a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15d1bcdeaeafe269fd21860f9cf3cb5"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af15d1bcdeaeafe269fd21860f9cf3cb5"><td class="memTemplItemLeft" align="right" valign="top">A &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#af15d1bcdeaeafe269fd21860f9cf3cb5">TypePunning</a> (B &amp;v)</td></tr>
<tr class="separator:af15d1bcdeaeafe269fd21860f9cf3cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f286de6aefd6d83c07893075ae39cc7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a9f286de6aefd6d83c07893075ae39cc7"><td class="memTemplItemLeft" align="right" valign="top">const A &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a9f286de6aefd6d83c07893075ae39cc7">TypePunning</a> (const B &amp;v)</td></tr>
<tr class="separator:a9f286de6aefd6d83c07893075ae39cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2827363ca08e6877a2389395e69f1d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2827363ca08e6877a2389395e69f1d34">&#9670;&nbsp;</a></span>get_template_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_util.html#a2827363ca08e6877a2389395e69f1d34">Util::get_template_type_t</a> = typedef typename <a class="el" href="struct_util_1_1get__template__type.html">get_template_type</a>&lt;C&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper typedef so that the above expression can be used like decltype. </p>

</div>
</div>
<a id="afb76d79dd0028154ff80d514ec0a66cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb76d79dd0028154ff80d514ec0a66cc">&#9670;&nbsp;</a></span>Pair</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_util.html#afb76d79dd0028154ff80d514ec0a66cc">Util::Pair</a> = typedef std::pair&lt;A, B&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap std::pair. </p>

</div>
</div>
<a id="a825706b32bf6453b12fa0ee6b23f3c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825706b32bf6453b12fa0ee6b23f3c0a">&#9670;&nbsp;</a></span>Tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_util.html#a825706b32bf6453b12fa0ee6b23f3c0a">Util::Tuple</a> = typedef std::tuple&lt;T...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap std::tuple. </p>

</div>
</div>
<a id="a643c93045063004fd71f71b9ab650116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643c93045063004fd71f71b9ab650116">&#9670;&nbsp;</a></span>tuple_array_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int MEMBER, class ... TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_util.html#a643c93045063004fd71f71b9ab650116">Util::tuple_array_t</a> = typedef <a class="el" href="namespace_util.html#a2827363ca08e6877a2389395e69f1d34">get_template_type_t</a>&lt;std::tuple_element_t&lt;MEMBER, std::tuple&lt;<a class="el" href="class_util_1_1_array.html">Util::Array</a>&lt;TYPES&gt;...&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type of contained element in <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Util::Array</a> stored in std::tuple. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3ae1584667288e11bb603d2a97f8f3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae1584667288e11bb603d2a97f8f3b5">&#9670;&nbsp;</a></span>__ImplementInterfaceSingleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Util::__ImplementInterfaceSingleton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_global_string_atom_table.html">Util::GlobalStringAtomTable</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34088cd8354fbb1c5ba2201b7b7b766a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34088cd8354fbb1c5ba2201b7b7b766a">&#9670;&nbsp;</a></span>__ImplementSingleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Util::__ImplementSingleton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_local_string_atom_table.html">Util::LocalStringAtomTable</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cff58ce5395906b4582f60064540e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cff58ce5395906b4582f60064540e9d">&#9670;&nbsp;</a></span>alloc_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::alloc_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for above expansion function. </p>

</div>
</div>
<a id="a3158c18bad3c53f6b28e106254d1bd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3158c18bad3c53f6b28e106254d1bd99">&#9670;&nbsp;</a></span>alloc_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::alloc_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks allocations for each member in a tuble. </p>

</div>
</div>
<a id="ac523806fb17029f288ac10791bbc7b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac523806fb17029f288ac10791bbc7b00">&#9670;&nbsp;</a></span>clear_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::clear_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for above expansion function. </p>

</div>
</div>
<a id="a33ba272acc88b6fd748bbb8a87898e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ba272acc88b6fd748bbb8a87898e26">&#9670;&nbsp;</a></span>clear_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::clear_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks allocations for each member in a tuple. </p>

</div>
</div>
<a id="ae530f444bfb138d60bb349da54c370fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae530f444bfb138d60bb349da54c370fc">&#9670;&nbsp;</a></span>CountBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> Util::CountBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af75aaffc78fa4b60acc0eab3048a67a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75aaffc78fa4b60acc0eab3048a67a1">&#9670;&nbsp;</a></span>erase_index_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::erase_index_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for erasing an element. </p>
<p>Keeps sorting but is generally slow due to shifting all element at i + 1 one step left. </p>

</div>
</div>
<a id="a168f16fd3a8fda426003a736f5271eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168f16fd3a8fda426003a736f5271eb9">&#9670;&nbsp;</a></span>erase_index_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::erase_index_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for erasing an element. </p>
<p>Keeps sorting but is generally slow due to shifting all element at i + 1 one step left. </p>

</div>
</div>
<a id="aabf36a01a5e4d697e89d1e9c96a333ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf36a01a5e4d697e89d1e9c96a333ac">&#9670;&nbsp;</a></span>erase_index_swap_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::erase_index_swap_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for erasing an element by swapping with the last and reducing size. </p>
<dl class="section note"><dt>Note</dt><dd>Destroys sorting! </dd></dl>

</div>
</div>
<a id="ad2694582e9f28c42d2a9a232f0b5ecb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2694582e9f28c42d2a9a232f0b5ecb3">&#9670;&nbsp;</a></span>erase_index_swap_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::erase_index_swap_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for erasing an element by swapping with the last and reducing size. </p>
<dl class="section note"><dt>Note</dt><dd>Destroys sorting! </dd></dl>

</div>
</div>
<a id="ad7b9c095e9e62c3bdb32ba0f821d40ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b9c095e9e62c3bdb32ba0f821d40ce">&#9670;&nbsp;</a></span>erase_range_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::erase_range_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for erasing a range of elements the last and reducing size. </p>

</div>
</div>
<a id="a0cc7f181637b51cb64ae41b54c94990d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc7f181637b51cb64ae41b54c94990d">&#9670;&nbsp;</a></span>erase_range_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::erase_range_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab2638a959006c26586a1cfe736b69a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2638a959006c26586a1cfe736b69a2">&#9670;&nbsp;</a></span>FastRandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Util::FastRandom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XorShift128 implementation. </p>
<p>Produces an xorshift128 pseudo random number. </p>

</div>
</div>
<a id="ad1f4a027212bb08db80e683d32bba73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f4a027212bb08db80e683d32bba73a">&#9670;&nbsp;</a></span>Get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int INDEX, typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::tuple_element_t&lt;INDEX, std::tuple&lt;A, B&gt; &gt;&amp; Util::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_util.html#afb76d79dd0028154ff80d514ec0a66cc">Pair</a>&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2472a8937bb807d50a59957c5a1953a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2472a8937bb807d50a59957c5a1953a">&#9670;&nbsp;</a></span>Get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int INDEX, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::tuple_element_t&lt;INDEX, std::tuple&lt;T...&gt; &gt;&amp; Util::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_util.html#a825706b32bf6453b12fa0ee6b23f3c0a">Tuple</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad79c549d8ff8d445ac5f1da15fb8fbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79c549d8ff8d445ac5f1da15fb8fbf1">&#9670;&nbsp;</a></span>HasBit() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Util::HasBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa0d0fdc87fd135ef2bedb030901cdb9c">int16</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a865e97c189979f35eaedc69446db24ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865e97c189979f35eaedc69446db24ff">&#9670;&nbsp;</a></span>HasBit() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Util::HasBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf6f87de2965e1bd5ccf45f48c14ef29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6f87de2965e1bd5ccf45f48c14ef29">&#9670;&nbsp;</a></span>HasBit() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Util::HasBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc7d7177fb7c733ce2a4bac52d61e7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7d7177fb7c733ce2a4bac52d61e7dc">&#9670;&nbsp;</a></span>HasBit() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Util::HasBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ac2a9e79eb120216f855626495b7bd18a">uint16</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a559a7a7139fa77cbf28c620a97aa614e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559a7a7139fa77cbf28c620a97aa614e">&#9670;&nbsp;</a></span>HasBit() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Util::HasBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c94977ecc1a4eacc0fe8a31e3703f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c94977ecc1a4eacc0fe8a31e3703f56">&#9670;&nbsp;</a></span>HasBit() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Util::HasBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b170e1e4792aa7e49d7882c77e6b6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b170e1e4792aa7e49d7882c77e6b6a4">&#9670;&nbsp;</a></span>MakePair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_util.html#afb76d79dd0028154ff80d514ec0a66cc">Pair</a>&lt;A, B&gt; Util::MakePair </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af20944172f5cd56d5812e38af506d25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20944172f5cd56d5812e38af506d25c">&#9670;&nbsp;</a></span>MakeTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_util.html#a825706b32bf6453b12fa0ee6b23f3c0a">Tuple</a>&lt;T...&gt; Util::MakeTuple </td>
          <td>(</td>
          <td class="paramtype">const T &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6bc91449daa6b35f6afdee2077e970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bc91449daa6b35f6afdee2077e970d">&#9670;&nbsp;</a></span>move_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::move_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for moving an element between two indices. </p>

</div>
</div>
<a id="a0b7a31bf982926a6211fe93fd169da5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7a31bf982926a6211fe93fd169da5e">&#9670;&nbsp;</a></span>move_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::move_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for moving an element between two indices. </p>

</div>
</div>
<a id="a811c01affad2fa10d98f73a902289b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811c01affad2fa10d98f73a902289b73">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00d8c93260d46c4231ebc583319a3fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d8c93260d46c4231ebc583319a3fb6">&#9670;&nbsp;</a></span>operator&quot;&quot;_atm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_string_atom.html">Util::StringAtom</a> Util::operator&quot;&quot;_atm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a611a1b2a9424f63b0efeb85caf1eaa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611a1b2a9424f63b0efeb85caf1eaa54">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_util_1_1_string.html">String</a> Util::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4081eb1dbd288fad7d8311cb8a967aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4081eb1dbd288fad7d8311cb8a967aee">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85738a75813ca34d463fa88bebb5c4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85738a75813ca34d463fa88bebb5c4b4">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5220ff5ebe65356ed98db0456a08d95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5220ff5ebe65356ed98db0456a08d95c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f22d08ff1e974fc94153df15f4ea8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f22d08ff1e974fc94153df15f4ea8a2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52c53e59acf6085a3bd071283e548502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c53e59acf6085a3bd071283e548502">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1be39e33c1bbdecfba94647576ff4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1be39e33c1bbdecfba94647576ff4e7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac60eccfe902320c6a743e610a663bf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60eccfe902320c6a743e610a663bf11">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacb507d0aacae89adff6e5bf5fbf30c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb507d0aacae89adff6e5bf5fbf30c4">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae237b3ce33a6eea3f5e7c7155b48f545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae237b3ce33a6eea3f5e7c7155b48f545">&#9670;&nbsp;</a></span>RandomFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Util::RandomFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thanks to Nic Werneck (<a href="https://xor0110.wordpress.com/2010/09/24/how-to-generate-floating-point-random-numbers-efficiently/">https://xor0110.wordpress.com/2010/09/24/how-to-generate-floating-point-random-numbers-efficiently/</a>) </p>
<p>Produces an xorshift128 psuedo based floating point random number in range 0..1 Note that this is not a truely random random number generator. </p>

</div>
</div>
<a id="a642cdeaf4c99cb9df42f40f245c6f07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642cdeaf4c99cb9df42f40f245c6f07e">&#9670;&nbsp;</a></span>RandomFloatNTP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Util::RandomFloatNTP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces an xorshift128 psuedo based floating point random number in range -1..1 Note that this is not a truely random random number generator. </p>

</div>
</div>
<a id="a804384bbbdcd9f697e89b2bc86b15fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804384bbbdcd9f697e89b2bc86b15fba">&#9670;&nbsp;</a></span>reserve_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::reserve_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for reserving in each array. </p>

</div>
</div>
<a id="a249e9aa97205b1b12c17aefd3b07df65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249e9aa97205b1b12c17aefd3b07df65">&#9670;&nbsp;</a></span>reserve_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::reserve_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for reserving in each array. </p>

</div>
</div>
<a id="a6b9f61b2d8d27bd199cf5d9b3b7902c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9f61b2d8d27bd199cf5d9b3b7902c4">&#9670;&nbsp;</a></span>set_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is, class... TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::set_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPES const &amp;...&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for setting values in each array at an index. </p>

</div>
</div>
<a id="a62ee071178937aed8148ce1b5fb46ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ee071178937aed8148ce1b5fb46ea7">&#9670;&nbsp;</a></span>set_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, class... TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::set_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPES const &amp;...&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for setting values in each array at an index. </p>

</div>
</div>
<a id="a0c334f60eb2cdfdf2e9272804e012a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c334f60eb2cdfdf2e9272804e012a34">&#9670;&nbsp;</a></span>set_size_for_each_in_tuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::set_size_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for reserving in each array. </p>

</div>
</div>
<a id="adb0e576da37feb940e959259ba7751d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0e576da37feb940e959259ba7751d2">&#9670;&nbsp;</a></span>set_size_for_each_in_tuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Util::set_size_for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for reserving in each array. </p>

</div>
</div>
<a id="adbcadd541631cff951e1856ea4ae5906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcadd541631cff951e1856ea4ae5906">&#9670;&nbsp;</a></span>SetBit() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_8h.html#aa0d0fdc87fd135ef2bedb030901cdb9c">int16</a> Util::SetBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#aa0d0fdc87fd135ef2bedb030901cdb9c">int16</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a86c99896c2a818350b124592d5867c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a86c99896c2a818350b124592d5867c">&#9670;&nbsp;</a></span>SetBit() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> Util::SetBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa73ad094ccb945cb6cfa59b8b9a1a7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73ad094ccb945cb6cfa59b8b9a1a7b1">&#9670;&nbsp;</a></span>SetBit() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Util::SetBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab41151ea39925673ec5f223a7eacf520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41151ea39925673ec5f223a7eacf520">&#9670;&nbsp;</a></span>SetBit() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_8h.html#ac2a9e79eb120216f855626495b7bd18a">uint16</a> Util::SetBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ac2a9e79eb120216f855626495b7bd18a">uint16</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace97aafdb9dec71c7d94958dbaa65d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace97aafdb9dec71c7d94958dbaa65d97">&#9670;&nbsp;</a></span>SetBit() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> Util::SetBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32469c5919e2ef24ec6de1835eb11804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32469c5919e2ef24ec6de1835eb11804">&#9670;&nbsp;</a></span>SetBit() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> Util::SetBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af15d1bcdeaeafe269fd21860f9cf3cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15d1bcdeaeafe269fd21860f9cf3cb5">&#9670;&nbsp;</a></span>TypePunning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">A&amp; Util::TypePunning </td>
          <td>(</td>
          <td class="paramtype">B &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f286de6aefd6d83c07893075ae39cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f286de6aefd6d83c07893075ae39cc7">&#9670;&nbsp;</a></span>TypePunning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const A&amp; Util::TypePunning </td>
          <td>(</td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="navelem"><a class="el" href="namespace_util.html">Util</a></li>
				<li class="footer">
					Generated on Sun Jan 17 2021 20:25:06 for Nebula. Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
